<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Simple 2D Racer v1.61i (taller canvas, full)</title>
<style>
  html,body{margin:0;background:#111;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto}
  #wrap{max-width:860px;margin:0 auto;padding:6px}
  #game{display:block;width:100%;height:auto;border:1px solid #333;background:#2b2b2b}
  #hud{display:flex;gap:6px;margin:6px 0;flex-wrap:wrap}
  .box{background:#000;border:1px solid #333;border-radius:6px;padding:6px 10px}
  #controls{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:6px}
  button{font-weight:800;font-size:16px;border-radius:12px;border:1px solid #444;background:#1a1a1a;color:#eee;padding:12px 0;touch-action:manipulation;-webkit-tap-highlight-color:transparent;
    -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;}
  button:active{filter:brightness(1.2)}
  #tip{opacity:.9;font-size:12px;margin-top:6px;line-height:1.5}
  #overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.65)}
  #overBox{background:#111;border:1px solid #444;border-radius:14px;padding:18px 22px;text-align:center}
  #overBox h2{margin:0 0 10px}
  .badge{padding:2px 6px;border-radius:6px;margin-left:6px;font-size:12px}
  .inv{background:#2e9bff}

  /* HUDの1段目/2段目を固定するための改行要素 */
  #hud .break{flex-basis:100%; height:0; padding:0; margin:0; border:0;}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="800" height="840"></canvas>
  <div id="hud">
    <div class="box">速度: <b id="spd">0</b> km/h</div>
    <div class="box">距離: <b id="dst">0</b> m</div>
    <div class="box">スコア: <b id="scr">0</b></div>
    <span class="break" aria-hidden="true"></span>
    <div class="box">残機: <b id="life">3</b></div>
    <div class="box">NITRO: <b id="nit">0%</b><span id="invTag" class="badge inv" style="display:none;">無敵</span></div>
    <span class="break" aria-hidden="true"></span>
<div class="box">ハイスコア: <b id="his">0</b></div>
    <div class="box">最長距離: <b id="bDst">0</b> m</div>
  </div>
  <div id="controls">
    <button id="btnStart">リセット</button>
    <button id="btnLeft">◀ 左</button>
    <button id="btnRight">右 ▶</button>
    <button id="btnNitro" aria-label="Nitro">ニトロ（長押し）</button>
  </div>
  <div id="tip">ニトロは長押し中のみ有効。コインで回復。</div>
</div>
<div id="overlay"><div id="overBox"><h2>GAME OVER</h2><div id="final"></div><button id="btnRestart">リスタート</button></div></div>

<script>
// ====== 基本寸法 ======
const W=800,H=840;
const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
const elSpd=document.getElementById('spd'), elDst=document.getElementById('dst'), elScr=document.getElementById('scr'), elLife=document.getElementById('life'), elNit=document.getElementById('nit'), invTag=document.getElementById('invTag'), elHis=document.getElementById('his'), elBDst=document.getElementById('bDst');

// ====== 状態 ======
let running=true, distance=0, score=0, lives=3;
let hiScore = parseInt(localStorage.getItem('racer_hiscore')||'0',10);
let bestDistance = parseInt(localStorage.getItem('racer_bestDistance')||'0',10);
let baseSpeed=180;
let nitro=0, nitroStock=100;
let nitroActive=false;           // 長押し状態
let damageCD=0;
let laneX=W*0.5, targetX=laneX;
let shake=0;

// ====== 入力 ======
const btnNitro=document.getElementById('btnNitro');
document.getElementById('btnStart').onclick=()=>startGame();
document.getElementById('btnLeft').onclick=()=>{ targetX-=60; };
document.getElementById('btnRight').onclick=()=>{ targetX+=60; };
document.getElementById('btnRestart').onclick=()=>{ hideOver(); startGame(); };

addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft'){ targetX-=60; }
  if(e.key==='ArrowRight'){ targetX+=60; }
  if(e.key==='ArrowUp'){ nitroActive=true; e.preventDefault(); }
},{passive:false});
addEventListener('keyup',e=>{
  if(e.key==='ArrowUp'){ nitroActive=false; e.preventDefault(); }
},{passive:false});

['pointerdown','touchstart','mousedown'].forEach(ev=>{
  btnNitro.addEventListener(ev, (e)=>{ nitroActive=true; e.preventDefault(); }, {passive:false});
});
['pointerup','pointercancel','touchend','touchcancel','mouseup','mouseleave'].forEach(ev=>{
  btnNitro.addEventListener(ev, (e)=>{ nitroActive=false; e.preventDefault(); }, {passive:false});
});

canvas.addEventListener('click',e=>{
  const r=canvas.getBoundingClientRect(); const x=e.clientX-r.left;
  if(x<r.width/2) targetX-=60; else targetX+=60;
});

function startGame(){
  if(elHis) elHis.textContent = hiScore;
  const dNow = Math.floor(distance);
  if(dNow>bestDistance){ bestDistance=dNow; localStorage.setItem('racer_bestDistance', bestDistance); }
  if(elBDst) elBDst.textContent = bestDistance;
  running=true; distance=0; score=0; baseSpeed=180; nitro=0; nitroStock=100; lives=3; damageCD=0; targetX=W*0.5;
  roadY=0; obstacles.length=0; coins.length=0; spawnTimer=0.55;
}

// ====== ループ ======
let roadY=0;
function getSpeedMS(){ const boost = nitro>0 ? 2.0 : 1.0; return (baseSpeed*boost)*1000/3600; }
function drawRoad(dt){
  const roadW=W*0.6, cx=W/2;
  ctx.fillStyle="#197b3c"; ctx.fillRect(0,0,W,H);
  ctx.fillStyle="#3d3d3d"; ctx.fillRect(cx-roadW/2,0,roadW,H);
  ctx.fillStyle="#bfbfbf"; ctx.fillRect(cx-roadW/2-10,0,10,H); ctx.fillRect(cx+roadW/2,0,10,H);
  ctx.fillStyle="#ffffff"; const stripeH= nitro>0? 54:34, gap= nitro>0? 20:34;
  roadY += getSpeedMS()*dt*0.50;
  for(let y=-((roadY%(stripeH+gap))); y<H; y+=stripeH+gap){ ctx.fillRect(cx-6,y,12,stripeH); }
  if(nitro>0){ ctx.globalAlpha=0.35; for(let i=0;i<20;i++){ const x=Math.random()*W; ctx.fillRect(x, Math.random()*H, 2, 30+Math.random()*90); } ctx.globalAlpha=1; ctx.fillStyle="rgba(60,140,255,0.08)"; ctx.fillRect(0,0,W,H); }
}

const car={x:laneX,y:H-90,w:44,h:70};
function drawCar(dt){
  targetX=Math.max(W*0.2, Math.min(W*0.8, targetX));
  car.x += (targetX - car.x) * Math.min(1, dt*8);
  ctx.fillStyle="rgba(0,0,0,0.35)"; ctx.beginPath(); ctx.ellipse(car.x, car.y+28, 26, 10, 0, 0, Math.PI*2); ctx.fill();
  const alpha=damageCD>0? 0.5+0.5*Math.sin(performance.now()/60):1; ctx.globalAlpha=alpha;
  ctx.fillStyle="#ff3b3b"; ctx.fillRect(car.x-car.w/2, car.y-car.h/2, car.w, car.h);
  ctx.fillStyle="#111"; ctx.fillRect(car.x-16, car.y-20, 32, 18);
  ctx.globalAlpha=1;
  if(nitro>0){ ctx.fillStyle="rgba(255,180,60,0.85)"; ctx.beginPath(); ctx.ellipse(car.x, car.y+car.h/2+12, 10+Math.random()*6, 16+Math.random()*6, 0, 0, Math.PI*2); ctx.fill(); }
}

const obstacles=[], coins=[];
let spawnTimer=0.55;
function poisson1D(minX,maxX,count,minGap){
  const xs=[]; let tries=0;
  while(xs.length<count && tries<50){
    const x=minX + Math.random()*(maxX-minX);
    if(xs.every(v=>Math.abs(v-x)>=minGap)){ xs.push(x); }
    tries++;
  }
  return xs;
}


function spawnStuff(){
  const cx=W*0.5;
  // 出現可能範囲＝プレイヤーの可動範囲と同一（端レーンも含む）
  const minX=W*0.2, maxX=W*0.8;

  // 60px刻みのレーン中心を「整数インデックス」で厳密に生成（ずれ防止）
  const step=60;
  const kMin = Math.ceil((minX - cx)/step);
  const kMax = Math.floor((maxX - cx)/step);
  const lanes=[];
  for(let k=kMin;k<=kMax;k++){ lanes.push(cx + k*step); }

  // 元仕様：80%で1体、20%で2体。レーンから重複無しで抽選
  const nObs = Math.random()<0.8 ? 1 : 2;
  const pool=lanes.slice(), chosen=[];
  while(chosen.length<nObs && pool.length){
    const i=Math.floor(Math.random()*pool.length);
    chosen.push(pool.splice(i,1)[0]);
  }
  for(const x of chosen){
    obstacles.push({x, y:-60 - Math.random()*60, w:40, h:60});
  }

  // コイン：障害物から50px以上離れるレーンから抽選（なければ中央）
  const free=lanes.filter(x=>chosen.every(v=>Math.abs(v-x)>=50));
  const cxCoin = free.length ? free[Math.floor(Math.random()*free.length)] : cx;
  coins.push({x:cxCoin, y:-40, r:12});
}
function updateStuff(dt){
  const vRef=(180*1000/3600);
  spawnTimer-=dt*(getSpeedMS()/vRef); if(spawnTimer<=0){ spawnStuff(); spawnTimer = 0.75 + Math.random()*0.25; }
  const vObj = getSpeedMS()*1.8;
  for(const o of obstacles){ o.y += vObj*dt; }
  for(const c of coins){ c.y += vObj*dt; }
  while(obstacles.length && obstacles[0].y>H+80) obstacles.shift();
  while(coins.length && coins[0].y>H+80) coins.shift();
  for(let i=obstacles.length-1;i>=0;i--){
    const o=obstacles[i];
    if(rectHit(car.x-car.w/2,car.y-car.h/2,car.w,car.h, o.x-o.w/2,o.y-o.h/2,o.w,o.h)){
      if(nitro>0){ score += 5; obstacles.splice(i,1); screenFlash=0.2; shake=12; }
      else if(damageCD<=0){ lives=Math.max(0,lives-1); damageCD=2.0; screenFlash=0.5; shake=12; if(lives<=0){ gameOver(); } break; }
    }
  }
  for(let i=coins.length-1;i>=0;i--){ const c=coins[i]; if(circleHit(car.x,car.y,24,c.x,c.y,c.r)){ coins.splice(i,1); score+=10; nitroStock=Math.min(100,nitroStock+8); } }
}
function rectHit(ax,ay,aw,ah, bx,by,bw,bh){ return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by; }
function circleHit(ax,ay,ar, bx,by,br){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy < (ar+br)*(ar+br); }

let screenFlash=0;
function drawHUD(dt){
  if(nitroActive && nitroStock>0){
    nitro=1.6;
    nitroStock=Math.max(0, nitroStock - dt*34);
  }else{
    nitro=0;
  }
  invTag.style.display = nitro>0 ? "inline-block":"none";

  baseSpeed=Math.min(1200, baseSpeed+dt*6);
  const roadMsVisual = getSpeedMS()*0.25; // 見た目のスクロール係数
const visKmh = Math.round(roadMsVisual*3.6);
elSpd.textContent = visKmh;
 elDst.textContent=Math.floor(distance); elScr.textContent=score; elLife.textContent=lives; elNit.textContent=Math.round(nitroStock)+"%";
  if(score>hiScore){ hiScore=score; localStorage.setItem('racer_hiscore', hiScore); }
  if(elHis) elHis.textContent = hiScore;
  // --- 最長距離をスコアと同じ仕組みで随時保存（最小差分） ---
  const dNow = Math.floor(distance);
  if(dNow>bestDistance){ bestDistance=dNow; localStorage.setItem('racer_bestDistance', bestDistance); }
  if(elBDst) elBDst.textContent = bestDistance;
  if(screenFlash>0){ screenFlash-=dt; ctx.fillStyle=`rgba(255,80,80,${Math.max(0,screenFlash)})`; ctx.fillRect(0,0,W,H); }
  if(damageCD>0) damageCD-=dt;
}

let last=performance.now();
function loop(ts){
  const dt=Math.min(0.033,(ts-last)/1000); last=ts;
  distance += getSpeedMS()*0.25*dt;
  if(shake>0){ shake=Math.max(0,shake-dt*20); ctx.save(); ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); }
  drawRoad(dt);
  if(running){ updateStuff(dt); }
  drawStuff();
  drawCar(dt);
  drawHUD(dt);
  if(shake>0){ ctx.restore(); }
  requestAnimationFrame(loop);
}
function drawStuff(){
  for(const o of obstacles){ ctx.fillStyle="#2aa8ff"; ctx.fillRect(o.x-o.w/2,o.y-o.h/2,o.w,o.h); ctx.fillStyle="#111"; ctx.fillRect(o.x-14,o.y-18,28,16); }
  for(const c of coins){ ctx.fillStyle="#ffd23f"; ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill(); ctx.strokeStyle="#bfa52e"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(c.x,c.y,c.r-3,0,Math.PI*2); ctx.stroke(); }
}

// ====== フィット（横は画面幅にフィット、縦はUI差し引きで最大化） ======
function measureUI(){
  const hud=document.getElementById('hud');
  const ctr=document.getElementById('controls');
  const tip=document.getElementById('tip');
  return (hud?.getBoundingClientRect().height||0)
       + (ctr?.getBoundingClientRect().height||0)
       + (tip?.getBoundingClientRect().height||0) + 8;
}
function fit(){
  const vv = window.visualViewport || {width: window.innerWidth, height: window.innerHeight};
  const ui = measureUI();
  const ratio = Math.min(vv.width/W, (vv.height-ui)/H);
  canvas.style.width=(W*ratio)+'px';
  canvas.style.height=(H*ratio)+'px';
}
addEventListener('resize',fit,{passive:true});
addEventListener('orientationchange',fit,{passive:true});
if('visualViewport' in window){ visualViewport.addEventListener('resize',fit,{passive:true}); }
if('fonts' in document){ document.fonts.ready.then(fit); }
fit();

function gameOver(){ running=false; document.getElementById('final').textContent=`スコア ${score} / 距離 ${Math.floor(distance)} m`; document.getElementById('overlay').style.display='flex'; }
function hideOver(){ document.getElementById('overlay').style.display='none'; }

requestAnimationFrame(loop);
</script>
</body>
</html>
