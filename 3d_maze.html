<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>3D 立体迷路（固定迷路 / タッチスティック / 明るさ強化）</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#121a2b;touch-action:none}
  #glcanvas{display:block;position:fixed;inset:0;z-index:0}

  #hud{
    position:fixed;left:12px;top:10px;z-index:80;
    color:#eef5ff;font:14px/1.45 system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
    background:rgba(12,16,28,.74);padding:10px 10px;border:1px solid rgba(255,255,255,.12);
    max-width:min(380px, calc(100vw - 24px));
    backdrop-filter: blur(10px);
    border-radius:12px;
  }
  .hudHeader{display:flex;align-items:center;justify-content:space-between;gap:10px}
  #hudToggle{background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.14);color:#eef5ff;border-radius:12px;padding:6px 10px;font:600 13px/1 system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif}
  #hudToggle:active{transform:translateY(1px)}
  #hud.collapsed{padding:10px 10px}
  #hud.collapsed .hudBody{display:none}

  #hud b{font-weight:700}
  #hud .row{margin-top:6px;opacity:.96}
  #hud .small{font-size:12px;opacity:.88}
  #btns{margin-top:6px;display:flex;gap:8px;flex-wrap:wrap}
  button{
    touch-action:manipulation;
    cursor:pointer;border:1px solid rgba(255,255,255,.20);
    background:rgba(255,255,255,.10);color:#eef5ff;padding:7px 10px;border-radius:10px
  }
  button:active{transform:translateY(1px)}
  #toast{
    position:fixed;left:50%;top:18px;transform:translateX(-50%);
    color:#eef5ff;background:rgba(12,16,28,.82);
    padding:10px 12px;border:1px solid rgba(255,255,255,.14);
    z-index:30;display:none;border-radius:12px
  }

  .stickBase{
    position:fixed;bottom:26px;width:150px;height:150px;border-radius:999px;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.14);
    z-index:25;pointer-events:auto;
    -webkit-user-select:none;user-select:none;
    backdrop-filter: blur(12px);
  }
  .stickKnob{
    position:absolute;left:50%;top:50%;
    width:64px;height:64px;border-radius:999px;
    transform:translate(-50%,-50%);
    background:rgba(255,255,255,.18);
    border:1px solid rgba(255,255,255,.18);
  }
  #stickL{left:18px}
    @media (max-width: 420px){
    .stickBase{width:132px;height:132px}
    .stickKnob{width:56px;height:56px}
  }
  @supports (padding: max(0px)){
    .stickBase{bottom: max(26px, env(safe-area-inset-bottom))}
  }
  #bar, #barSens, #barFov{
    margin-top:6px;display:flex;align-items:center;gap:8px;
    flex-wrap:nowrap; /* ラベル差でスライダー位置がズレないように固定 */
  }
  #bar label, #barSens label, #barFov label{
    font-size:12px;opacity:.92;
    width:52px; flex:0 0 52px; /* ラベル幅を固定して開始位置を統一 */
  }
  #bar .small, #barSens .small, #barFov .small{
    width:44px; flex:0 0 44px; text-align:right; /* 右側の数値も揃える */
  }
  #bar input[type="range"], #barSens input[type="range"], #barFov input[type="range"]{
    flex:1 1 auto; min-width:0; width:auto; /* 幅は自動で揃える */
  }
/* --- Menu overlay --- */
  #menuOverlay{
    pointer-events:auto;
    position:fixed; inset:0; z-index:80;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.55);
    backdrop-filter: blur(8px);
  }
  #menuPanel{
    width:min(86vw, 420px);
    background:rgba(12,16,28,.88);
    border:1px solid rgba(255,255,255,.14);
    border-radius:14px;
    padding:14px;
    color:#eef5ff;
  }
  #menuPanel h1{
    margin:0 0 10px 0;
    font-size:16px;
    font-weight:700;
  }
  #diffBtns{display:flex; gap:10px; flex-wrap:wrap}
  #diffBtns button{flex:1; min-width:90px}
  #menuNote{margin-top:10px; font-size:12px; opacity:.85}

  /* --- Goal flash --- */
  #flash{
    position:fixed; inset:0; z-index:70;
    pointer-events:none;
    background:rgba(180,255,255,0.0);
    display:none;
  }


  /* --- Answer / MiniMap (non-modal) --- */
  #mapOverlay{
    position:fixed; left:0; top:0; width:0; height:0; z-index:65;
    display:none;
    pointer-events:auto; /* iOSで子要素のボタンが効かない対策（画面全体はブロックしない） */
  }
  #mapPanel{
    position:fixed;
    right:12px;
    top: 132px;
    width:min(46vw, 260px);
    max-width:260px;
    background:rgba(12,16,28,.86);
    border:1px solid rgba(255,255,255,.14);
    border-radius:14px;
    padding:12px;
    color:#eef5ff;
    pointer-events:auto; /* パネル内だけ操作可 */
    backdrop-filter: blur(10px);
  }
  #mapHeader{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; margin-bottom:10px;
  }
  #mapHeader b{font-weight:700}
  #mapClose{
    border:1px solid rgba(255,255,255,.20);
    background:rgba(255,255,255,.10);
    color:#eef5ff;
    padding:6px 10px;
    border-radius:10px;
    cursor:pointer;
  }
  #mapCanvas{
    position:static;
    width:100%;
    height:auto;
    display:block;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.03);
  }


  /* --- Game Over --- */
  #gameOver{
    position:fixed; inset:0; z-index:90;
    display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.68);
    backdrop-filter: blur(10px);
  }
  #gameOverPanel{
    width:min(86vw, 420px);
    background:rgba(12,16,28,.90);
    border:1px solid rgba(255,255,255,.14);
    border-radius:14px;
    padding:14px;
    color:#eef5ff;
    text-align:center;
  }
  #gameOverPanel h2{
    margin:6px 0 10px 0;
    font-size:18px;
  }


  /* --- Goal text (flashy) --- */
  #goalText{
    position:fixed; left:50%; top:44%;
    transform:translate(-50%,-50%);
    z-index:85;
    pointer-events:none;
    display:none;
    font:900 clamp(40px, 10vw, 92px)/1 system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
    letter-spacing: 0.08em;
    color: rgba(235,255,255,0.98);
    text-shadow:
      0 0 10px rgba(120,250,255,0.55),
      0 0 22px rgba(120,250,255,0.38),
      0 0 48px rgba(120,250,255,0.22);
    filter: drop-shadow(0 10px 24px rgba(0,0,0,0.45));
    mix-blend-mode: screen;
    will-change: transform, opacity, filter;
  }
  #goalText.show{
    display:block;
    animation: goalPop 900ms ease-out both;
  }
  #goalText.show.normal{
    animation: goalPop 1050ms ease-out both, goalPulse 900ms ease-in-out 1 both;
  }
  #goalText.show.hard{
    animation: goalPop 1100ms ease-out both, goalPulse 1200ms ease-in-out 1 both, goalShake 850ms ease-in-out 1 both;
  }
  @keyframes goalPop{
    0%{ opacity:0; transform:translate(-50%,-50%) scale(0.55) rotate(-6deg); filter:blur(2px) drop-shadow(0 10px 24px rgba(0,0,0,0.45)); }
    35%{ opacity:1; transform:translate(-50%,-50%) scale(1.22) rotate(2deg); filter:blur(0px) drop-shadow(0 10px 28px rgba(0,0,0,0.55)); }
    70%{ opacity:1; transform:translate(-50%,-50%) scale(1.06) rotate(0deg); }
    100%{ opacity:0; transform:translate(-50%,-50%) scale(0.96) rotate(0deg); }
  }
  @keyframes goalPulse{
    0%{ text-shadow:0 0 10px rgba(120,250,255,0.55),0 0 22px rgba(120,250,255,0.38),0 0 48px rgba(120,250,255,0.22); }
    50%{ text-shadow:0 0 16px rgba(255,255,255,0.80),0 0 34px rgba(120,250,255,0.62),0 0 70px rgba(120,250,255,0.35); }
    100%{ text-shadow:0 0 10px rgba(120,250,255,0.55),0 0 22px rgba(120,250,255,0.38),0 0 48px rgba(120,250,255,0.22); }
  }
  @keyframes goalShake{
    0%{ transform:translate(-50%,-50%) scale(0.72) rotate(-8deg); }
    18%{ transform:translate(calc(-50% - 4px), calc(-50% + 2px)) scale(1.20) rotate(4deg); }
    38%{ transform:translate(calc(-50% + 4px), calc(-50% - 2px)) scale(1.10) rotate(-3deg); }
    58%{ transform:translate(calc(-50% - 3px), calc(-50% + 1px)) scale(1.06) rotate(2deg); }
    78%{ transform:translate(calc(-50% + 2px), calc(-50% - 1px)) scale(1.02) rotate(-1deg); }
    100%{ transform:translate(-50%,-50%) scale(0.98) rotate(0deg); }
  }


  /* --- Goal screen shake (hard) --- */
  body.goalShake #glcanvas{
    animation: screenShake 420ms linear infinite;
    will-change: transform;
  }
  @keyframes screenShake{
    0%{ transform:translate(0,0) }
    10%{ transform:translate(-2px, 1px) }
    20%{ transform:translate(2px, -1px) }
    30%{ transform:translate(-3px, -1px) }
    40%{ transform:translate(3px, 2px) }
    50%{ transform:translate(-1px, -2px) }
    60%{ transform:translate(2px, 2px) }
    70%{ transform:translate(-2px, 1px) }
    80%{ transform:translate(3px, -2px) }
    90%{ transform:translate(-3px, 2px) }
    100%{ transform:translate(0,0) }
  }

</style>
</head>
<body>
<div id="toast"></div>
<div id="flash"></div>
<div id="goalText">GOAL</div>
<div id="gameOver">
  <div id="gameOverPanel">
    <h2>ゲームオーバー</h2>
    <div style="opacity:.9;font-size:13px;margin-bottom:12px">敵に触れた</div>
    <button id="goMenu">メニューへ戻る</button>
  </div>
</div>


<div id="menuOverlay">
  <div id="menuPanel">
    <div id="menuHeader" style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
  <h1 style="margin:0;font-size:16px;font-weight:700">3D 立体迷路</h1>
  <button id="menuClose" style="padding:6px 10px;border-radius:10px">閉じる</button>
</div>
    <div id="diffBtns">
      <button id="diffEasy">簡単</button>
      <button id="diffNormal">普通</button>
      <button id="diffHard">難しい</button>
    </div>
    <div id="menuNote">難易度を選ぶとスタートします</div>
  </div>
</div>


<div id="hud" style="display:none">
  <div class="hudHeader"><div><b>3D 立体迷路</b></div><button id="hudToggle" type="button">閉じる</button></div>

  <div class="hudBody">

  <div id="bar">
    <label for="bright">明るさ</label>
    <input id="bright" type="range" min="1.0" max="5.0" step="0.05" value="3.00">
    <span id="bval" class="small">4.00</span>
  </div>


  <div id="barSens">
    <label for="sens">感度</label>
    <input id="sens" type="range" min="0.0035" max="0.0155" step="0.0001" value="0.0065">
    <span id="sval" class="small">6.5</span>
  </div>


  <div id="barFov">
    <label for="fov">視野角</label>
    <input id="fov" type="range" min="55" max="95" step="1" value="75">
    <span id="fovVal" class="small">75</span>
  </div>


    <button id="reset">スタートに戻る</button>
    <button id="btnDifficulty">難易度</button>
    <button id="btnFoot">足跡:OFF</button>
    <button id="hint">ヒント</button>
    <button id="answer">答え</button>
  </div>
  </div>
</div>


<div id="mapOverlay">
  <div id="mapPanel">
    <div id="mapHeader">
      <b>迷路の全体像</b>
      <button id="mapClose">閉じる</button>
    </div>
    <canvas id="mapCanvas" width="320" height="320"></canvas>
    <div style="margin-top:8px;font-size:12px;opacity:.88"><span style="color:rgba(255,120,120,0.98)">●</span> あなた　<span style="color:rgba(120,250,255,0.95)">●</span> ゴール　<span style="color:rgba(255,90,130,0.95)">●</span> 敵</div>
  </div>
</div>

<div id="stickL" class="stickBase"><div class="stickKnob"></div></div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

// ---------- UI ----------
const toastEl = document.getElementById("toast");
const flashEl = document.getElementById("flash");
const goalTextEl = document.getElementById("goalText");
const menuOverlay = document.getElementById("menuOverlay");
const diffEasy = document.getElementById("diffEasy");
const diffNormal = document.getElementById("diffNormal");
const diffHard = document.getElementById("diffHard");

const hud = document.getElementById("hud");
const hudToggle = document.getElementById("hudToggle");
let hudCollapsed = false;
function setHudCollapsed(v){
  hudCollapsed = v;
  hud.classList.toggle("collapsed", v);
  hudToggle.textContent = v ? "メニュー" : "閉じる";
  positionMapPanel();
}
let _hudToggleT = 0;
function toggleHud(){
  const now = performance.now();
  if(now - _hudToggleT < 250) return;
  _hudToggleT = now;
  setHudCollapsed(!hudCollapsed);
}
hudToggle.addEventListener("click", (e)=>{ e.stopPropagation(); toggleHud(); });
hudToggle.addEventListener("pointerdown", (e)=>{ toggleHud(); e.preventDefault(); e.stopPropagation(); });
hudToggle.addEventListener("touchstart", (e)=>{ toggleHud(); e.preventDefault(); e.stopPropagation(); }, {passive:false});

function positionMapPanel(){
  if(!mapPanel) return;
  if(!mapOverlay || mapOverlay.style.display !== "block") return;
  requestAnimationFrame(()=>{
    const r = hud.getBoundingClientRect();
    const pad = 10;
    const pr = mapPanel.getBoundingClientRect();
    const panelH = pr.height || 360;
    let top = Math.round(r.bottom + pad);
    let maxTop = window.innerHeight - panelH - 12;
    if(maxTop < 12) maxTop = 12;
    if(top > maxTop) top = maxTop;
    mapPanel.style.top = top + "px";
  });
}

const padEl = document.getElementById("pad");
const btnReset = document.getElementById("reset");
const btnAnswer = document.getElementById("answer");
const mapOverlay = document.getElementById("mapOverlay");
const mapClose = document.getElementById("mapClose");
const mapCanvas = document.getElementById("mapCanvas");
const mapCtx = mapCanvas?.getContext?.("2d");
const mapPanel = document.getElementById("mapPanel");
const brightEl = document.getElementById("bright");
const bvalEl = document.getElementById("bval");
const sensEl = document.getElementById("sens");
const svalEl = document.getElementById("sval");
const fovEl = document.getElementById("fov");
const fovValEl = document.getElementById("fovVal");
const btnDifficulty = document.getElementById("btnDifficulty");
const btnFoot = document.getElementById("btnFoot");
const btnHint = document.getElementById("hint");
const menuClose = document.getElementById("menuClose");
const menuHeader = document.getElementById("menuHeader");

function updateMenuHeaderVisibility(){
  // 初回は「難易度選択のみ」にする（タイトル/閉じるを隠す）
  const show = !!hasStarted;
  if(menuHeader) menuHeader.style.display = show ? "flex" : "none";
}

const gameOverEl = document.getElementById("gameOver");
const goMenuBtn = document.getElementById("goMenu");

function toast(msg, ms=1400){
  toastEl.textContent = msg;
  toastEl.style.display = "block";
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(()=>toastEl.style.display="none", ms);
}


// ---------- Renderer ----------
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;

// 明るさが効きやすい
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = parseFloat(brightEl.value) + 1.0;
document.body.appendChild(renderer.domElement);
renderer.domElement.id = "glcanvas";
renderer.domElement.style.zIndex = "0";

brightEl.addEventListener("input", ()=>{
  const v = parseFloat(brightEl.value);
  renderer.toneMappingExposure = (v + 1.0);
  bvalEl.textContent = (v + 1.0).toFixed(2);
});


let swipeSens = 0.0055; // 画面スワイプ視点の感度（デフォルトは現状値）
// 感度バー（デフォルトは現状の感度）
if(sensEl && svalEl){
  const v = parseFloat(sensEl.value);
  swipeSens = v;
  svalEl.textContent = (v * 1000.0).toFixed(1);
}
sensEl?.addEventListener("input", ()=>{
  const v = parseFloat(sensEl.value);
  swipeSens = v;
  if(svalEl) svalEl.textContent = (v * 1000.0).toFixed(1);
});

// ---------- FOV ----------
let desiredFov = 75;
try{
  const saved = localStorage.getItem("maze_fov");
  if(saved != null){
    const v = parseFloat(saved);
    if(Number.isFinite(v)) desiredFov = Math.max(55, Math.min(95, v));
  }
}catch(_){}

if(fovEl && fovValEl){
  fovEl.value = String(desiredFov|0);
  fovValEl.textContent = String(desiredFov|0);
}

// ---------- Scene ----------
const scene = new THREE.Scene();

// 霧を少し明るく（暗い雰囲気は残す）
const fogColor = 0x121a2b;
scene.background = new THREE.Color(fogColor);
scene.fog = new THREE.Fog(fogColor, 7.0, 24.0);

const camera = new THREE.PerspectiveCamera(desiredFov, innerWidth/innerHeight, 0.1, 260);

// FOVスライダー（メニュー幅は増やさず：短いラベル＋短いレンジ）
fovEl?.addEventListener("input", ()=>{
  const v = Math.max(55, Math.min(95, parseFloat(fovEl.value)));
  desiredFov = v;
  if(fovValEl) fovValEl.textContent = String(v|0);
  camera.fov = v;
  camera.updateProjectionMatrix();
  try{ localStorage.setItem("maze_fov", String(v)); }catch(_){}
});

// 光を強化（ただし“暗い雰囲気”は維持）
scene.add(new THREE.AmbientLight(0xffffff, 0.30));
scene.add(new THREE.HemisphereLight(0xb2c7ff, 0x24143b, 1.15));

const dir = new THREE.DirectionalLight(0xffffff, 1.05);
dir.position.set(7, 12, 5);
scene.add(dir);

// 懐中電灯（前方視認性を上げる）
const torch = new THREE.SpotLight(0xffe0bb, 2.6, 18, Math.PI/5.5, 0.25, 1.5);
torch.castShadow = false;
scene.add(torch);
scene.add(torch.target);

// 補助の冷色リムライト
const rim = new THREE.PointLight(0x7fd4ff, 0.55, 14, 2);
scene.add(rim);

/* ---------- Hint arrow ---------- */
let hintUntil = 0;

// 小さい“立体”矢印（シャフト＋コーン）。カメラの目の前に固定し、視点変更に応じてその場で回転。
// ※ビルボード(常に正面向き)にしない：少し傾けて厚みが見えるようにする。
const hintArrow = new THREE.Group();

const hintMat = new THREE.MeshStandardMaterial({
  color: 0x86f7ff,
  emissive: 0x2ac7ff,
  emissiveIntensity: 1.35,
  roughness: 0.35,
  metalness: 0.08,
  transparent: true,
  opacity: 0.96
});
// HUDなので奥行き/霧の影響を受けにくく
hintMat.depthTest = false;
hintMat.fog = false;

const shaftLen = 0.26;
const shaftRad = 0.028;
const headLen  = 0.17;
const headRad  = 0.11;

// Cylinder/ConeはY軸方向が長さ。Z方向へ向くように回す。
const shaftGeo = new THREE.CylinderGeometry(shaftRad, shaftRad, shaftLen, 12, 1, false);
shaftGeo.rotateX(Math.PI/2); // Y->Z
const shaft = new THREE.Mesh(shaftGeo, hintMat);
shaft.position.z = -(shaftLen * 0.5);
shaft.renderOrder = 2000;

const headGeo = new THREE.ConeGeometry(headRad, headLen, 24, 1, false);
headGeo.rotateX(Math.PI/2); // Y->Z
headGeo.rotateY(Math.PI); // 先を-Zへ（尖りを前に）
const head = new THREE.Mesh(headGeo, hintMat);
head.position.z = -(shaftLen + headLen*0.5);
head.renderOrder = 2000;

hintArrow.add(shaft, head);

// （矢羽根は撤去：矢印が分かりやすい形状を優先）


// 輪郭強調（薄いアウトライン）
const outlineMat = new THREE.MeshBasicMaterial({
  color: 0xffffff,
  transparent: true,
  opacity: 0.12,
  depthTest: false,
  fog: false
});
outlineMat.blending = THREE.AdditiveBlending;

const shaftO = new THREE.Mesh(shaftGeo.clone(), outlineMat);
shaftO.scale.setScalar(1.18);
shaftO.position.copy(shaft.position);
shaftO.renderOrder = 1999;

const headO = new THREE.Mesh(headGeo.clone(), outlineMat);
headO.scale.setScalar(1.18);
headO.position.copy(head.position);
headO.renderOrder = 1999;

hintArrow.add(shaftO, headO);

hintArrow.renderOrder = 2000;
hintArrow.visible = false;
scene.add(hintArrow);

function triggerHint(now){
  hintUntil = now + 2000; // 2 seconds
  hintArrow.visible = true;
  toast("ヒント表示", 700);
}
btnHint?.addEventListener("click", ()=>triggerHint(performance.now()));
btnHint?.addEventListener("touchstart", (e)=>{ triggerHint(performance.now()); e.preventDefault(); e.stopPropagation(); }, {passive:false});

function updateHintArrow(now){
  if(!hintArrow.visible) return;
  if(now > hintUntil){
    hintArrow.visible = false;
    return;
  }

  // ゴール方向（ワールド）と視線（player.yaw）の差＝矢印の回転角
  const vx = (world.goal.x - player.pos.x);
  const vz = (world.goal.z - player.pos.z);
  const goalYaw = Math.atan2(vx, vz); // yaw=0 は +Z
  let rel = goalYaw - player.yaw;
  rel = ((rel + Math.PI) % (Math.PI*2)) - Math.PI;

  // カメラの少し前に固定（HUD風）
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); // camera forward
  const up = new THREE.Vector3(0,1,0).applyQuaternion(camera.quaternion);
  const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);

  // 目の前・中央寄り（少し下）
  hintArrow.position.copy(camera.position)
    .addScaledVector(forward, 0.85)
    .addScaledVector(up, -0.10)
    .addScaledVector(right, 0.00);

  // カメラに追従。ただし少し傾けて厚みが見えるようにする
  hintArrow.quaternion.copy(camera.quaternion);
  hintArrow.rotateX(0.35);         // 立体感（固定チルト）
  hintArrow.rotateY(rel);          // 左右回転（視点変更でクルクル）
  hintArrow.rotateZ(0.08);         // ほんの少しだけロール

  // 小さめ固定
  hintArrow.scale.setScalar(1.0);
}


// ---------- Seeded RNG（迷路を固定化） ----------
function mulberry32(seed){
  let t = seed >>> 0;
  return function(){
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
const RNG_SEED = 0xC0FFEE;   // 互換用（※迷路用乱数は難易度ごとに分離）
const rand = mulberry32(RNG_SEED);

// ---------- Game state / Difficulty ----------
const DIFF = {
  easy:   { label:"簡単",  W:21, H:21, seed:0xE45DBEEF, extra:0.09 },
  normal: { label:"普通",  W:27, H:27, seed:0xA11CE0DE, extra:0.06 },
  hard:   { label:"難しい",W:31, H:31, seed:0xC0FFEE,  extra:0.05 },
};
let currentDiffKey = "hard"; // 現在の難易度（初期は難しい）
let gameInMenu = true;
let goalReached = false;
let hasStarted = false;

// ---------- Procedural textures ----------
function makeNoiseTexture(opts){
  const size = 256;
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const g = c.getContext("2d");

  const grad = g.createLinearGradient(0,0,size,size);
  grad.addColorStop(0, opts.c1);
  grad.addColorStop(1, opts.c2);
  g.fillStyle = grad;
  g.fillRect(0,0,size,size);

  const img = g.getImageData(0,0,size,size);
  const d = img.data;
  for(let i=0;i<d.length;i+=4){
    const n = (rand()*255)|0;
    const a = opts.alpha;
    d[i+0] = d[i+0]*(1-a) + n*a;
    d[i+1] = d[i+1]*(1-a) + n*a;
    d[i+2] = d[i+2]*(1-a) + n*a;
    d[i+3] = 255;
  }
  g.putImageData(img,0,0);

  // ---- subtle grid / edge cues ----
  const minorStep = opts.gridStepMinor ?? 32;
  const majorStep = opts.gridStepMajor ?? (minorStep*2);
  const minorA = opts.gridAlphaMinor ?? 0.18;
  const majorA = opts.gridAlphaMajor ?? 0.14;

  // minor lines
  g.globalAlpha = minorA;
  g.strokeStyle = opts.gridColorMinor ?? "rgba(255,255,255,0.22)";
  g.lineWidth = 1;
  for(let x=0;x<=size;x+=minorStep){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,size); g.stroke(); }
  for(let y=0;y<=size;y+=minorStep){ g.beginPath(); g.moveTo(0,y); g.lineTo(size,y); g.stroke(); }

  // major lines
  g.globalAlpha = majorA;
  g.strokeStyle = opts.gridColorMajor ?? "rgba(120,250,255,0.16)";
  g.lineWidth = 2;
  for(let x=0;x<=size;x+=majorStep){ g.beginPath(); g.moveTo(x+0.5,0); g.lineTo(x+0.5,size); g.stroke(); }
  for(let y=0;y<=size;y+=majorStep){ g.beginPath(); g.moveTo(0,y+0.5); g.lineTo(size,y+0.5); g.stroke(); }

  g.globalAlpha = 1;

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy?.() ?? 8);
  return tex;
}

const texWall = makeNoiseTexture({ c1:"#2c3a58", c2:"#1e2a42", alpha:0.07 });
texWall.repeat.set(2,2);
const texFloor = makeNoiseTexture({ c1:"#2a2148", c2:"#151c34", alpha:0.09, gridStepMinor:16, gridStepMajor:64, gridAlphaMinor:0.28, gridAlphaMajor:0.18, gridColorMinor:"rgba(255,255,255,0.26)", gridColorMajor:"rgba(120,250,255,0.20)" });
texFloor.repeat.set(4,4);

// ---------- Maze (fixed) ----------
function makeMaze(w, h, r, extraRatio){
  const grid = Array.from({length:h}, ()=>Array(w).fill(1));
  const inb = (x,y)=>x>0 && y>0 && x<w-1 && y<h-1;

  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = (r()*(i+1))|0;
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
  }

  function carve(x,y){
    grid[y][x] = 0;
    const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
    shuffle(dirs);
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if(inb(nx,ny) && grid[ny][nx]===1){
        grid[y+dy/2][x+dx/2] = 0;
        carve(nx,ny);
      }
    }
  }
  carve(1,1);

  // “少しだけ”穴を足す（これも固定乱数）
  const extra = Math.floor(w*h*(extraRatio ?? 0.02));
  for(let k=0;k<extra;k++){
    const x = 1 + ((r()*(w-2))|0);
    const y = 1 + ((r()*(h-2))|0);
    if(grid[y][x]===1) grid[y][x]=0;
  }
  // 行き止まり（一本道）が多すぎないように、死に道を一部だけ崩してループを増やす
  const dirs1 = [[1,0],[-1,0],[0,1],[0,-1]];
  function openNeighbors(x,y){
    let c=0;
    for(const [dx,dy] of dirs1){
      if(grid[y+dy]?.[x+dx]===0) c++;
    }
    return c;
  }
  // 何回か走査して、行き止まりセルの近くを軽く開ける
  const rounds = 2;
  const triesPerRound = Math.floor(w*h*0.22);
  for(let rr=0; rr<rounds; rr++){
    for(let t=0; t<triesPerRound; t++){
      const x = 1 + ((r()*(w-2))|0);
      const y = 1 + ((r()*(h-2))|0);
      if(grid[y][x]!==0) continue;
      if((x===1 && y===1)) continue;
      if(openNeighbors(x,y)!==1) continue; // 行き止まりっぽい
      // 壁を1枚だけ開けて分岐を増やす（ただし境界は避ける）
      const cand = [];
      for(const [dx,dy] of dirs1){
        const nx=x+dx, ny=y+dy;
        if(nx<=0||ny<=0||nx>=w-1||ny>=h-1) continue;
        if(grid[ny][nx]===1){
          // その先が通路なら最短でループができる
          const nnx=nx+dx, nny=ny+dy;
          if(grid[nny]?.[nnx]===0) cand.push([nx,ny]);
        }
      }
      if(cand.length){
        const pick = cand[(r()*cand.length)|0];
        grid[pick[1]][pick[0]] = 0;
      }
    }
  }

  return grid;
}

// ---------- World build ----------
const cellSize = 1.6;
const wallHeight = 4.9;
const floorY = 0;

const world = {
  group: new THREE.Group(),
  grid: null,
  w: 0, h: 0,
  start: new THREE.Vector3(),
  goal: new THREE.Vector3(),
  goalMesh: null,
};
scene.add(world.group);

const matWall = new THREE.MeshStandardMaterial({
  color: 0x445a7a,
  map: texWall,
  roughness: 0.82,
  metalness: 0.04,
  emissive: 0x0a1930,
  emissiveIntensity: 0.35,
});

const matFloor = new THREE.MeshStandardMaterial({
  color: 0x3a2e5b,
  map: texFloor,
  roughness: 1.0,
  metalness: 0.0,
  emissive: 0x0b0712,
  emissiveIntensity: 0.18,
});

const matGoal  = new THREE.MeshStandardMaterial({
  color: 0x9af6ff,
  emissive: 0x4aaec0,
  emissiveIntensity: 1.8,
  roughness: 0.35
});

// ---------- Footprints ----------
let footprintsEnabled = false;
let visited = new Set();
let footGroup = new THREE.Group();
let footTex = null;
let footMat = null;
let footGeo = null;

function makeFootTex(){
  const c = document.createElement("canvas");
  c.width = c.height = 128;
  const g = c.getContext("2d");
  g.clearRect(0,0,128,128);

  // subtle glow base
  const grd = g.createRadialGradient(64,72,6,64,72,52);
  grd.addColorStop(0, "rgba(180,255,255,0.22)");
  grd.addColorStop(1, "rgba(180,255,255,0.0)");
  g.fillStyle = grd;
  g.beginPath(); g.ellipse(64,78,34,26,0,0,Math.PI*2); g.fill();

  // footprint shape
  g.fillStyle = "rgba(220,245,255,0.42)";
  g.beginPath(); g.ellipse(64,82,18,26,0,0,Math.PI*2); g.fill(); // sole
  g.globalAlpha = 0.34;
  for(const [x,y,r] of [[50,52,5],[62,46,5],[74,46,5],[86,52,4],[94,60,3]]){
    g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
  }
  g.globalAlpha = 1;

  const t = new THREE.CanvasTexture(c);
  t.colorSpace = THREE.SRGBColorSpace;
  t.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy?.() ?? 8);
  return t;
}

function ensureFootAssets(){
  if(!footTex) footTex = makeFootTex();
  if(!footMat){
    footMat = new THREE.MeshBasicMaterial({
      map: footTex,
      transparent: true,
      opacity: 0.85,
      depthWrite: false
    });
  }
  if(!footGeo){
    const s = cellSize * 0.75;
    footGeo = new THREE.PlaneGeometry(s, s);
  }
}

function clearFootprints(){
  visited.clear();
  if(footGroup){
    while(footGroup.children.length) footGroup.remove(footGroup.children[0]);
  }
}

function setFootprintsEnabled(on){
  footprintsEnabled = !!on;
  if(btnFoot) btnFoot.textContent = footprintsEnabled ? "足跡:ON" : "足跡:OFF";
  if(footGroup) footGroup.visible = footprintsEnabled;
}

function clearWorld(){
  while(world.group.children.length) world.group.remove(world.group.children[0]);
  world.goalMesh = null;
  // footprints are part of world.group -> cleared here
  footGroup = new THREE.Group();
  footGroup.visible = footprintsEnabled;
  visited.clear();
}

function buildWorldByDifficulty(key){
  const cfg = DIFF[key] ?? DIFF.hard;
  currentDiffKey = key;

  const rMaze = mulberry32(cfg.seed >>> 0);
  clearWorld();

  const W = cfg.W, H = cfg.H;
  const grid = makeMaze(W,H, rMaze, cfg.extra);
  world.grid = grid; world.w = W; world.h = H;

  const floorGeo = new THREE.PlaneGeometry(W*cellSize, H*cellSize);
  const floor = new THREE.Mesh(floorGeo, matFloor);
  floor.rotation.x = -Math.PI/2;
  floor.position.set((W-1)*cellSize/2, floorY, (H-1)*cellSize/2);
  world.group.add(floor);

  ensureFootAssets();
  world.group.add(footGroup);

  const wallGeo = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);
// 壁の輪郭（視認性UP）：薄いエッジライン
  const wallEdgeGeo = new THREE.EdgesGeometry(wallGeo, 22);
  const wallEdgeMat = new THREE.LineBasicMaterial({ color: 0xbfe7ff, transparent:true, opacity:0.18 });
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      if(grid[y][x]===1){
        const wall = new THREE.Mesh(wallGeo, matWall);
        // エッジ（子にすると位置/回転が同期）
        const edge = new THREE.LineSegments(wallEdgeGeo, wallEdgeMat);
        edge.position.set(0,0,0);
        wall.add(edge);
        wall.position.set(x*cellSize, floorY + wallHeight/2, y*cellSize);
        world.group.add(wall);
      }
    }
  }

  world.start.set(1*cellSize, 1.65, 1*cellSize);

  let gx= W-2, gy= H-2;
  for(let tries=0; tries<2500; tries++){
    const x = 1 + ((rMaze()*(W-2))|0);
    const y = 1 + ((rMaze()*(H-2))|0);
    if(grid[y][x]===0){
      const dx=x-1, dy=y-1;
      if(dx*dx+dy*dy > (W*0.55)*(W*0.55)) { gx=x; gy=y; break; }
    }
  }
  world.goal.set(gx*cellSize, 1.1, gy*cellSize);

  const goalGeo = new THREE.SphereGeometry(0.36, 20, 16);
  const goal = new THREE.Mesh(goalGeo, matGoal);
  goal.position.copy(world.goal);
  world.group.add(goal);
  world.goalMesh = goal;
}

buildWorldByDifficulty(currentDiffKey);

// ---------- Answer / MiniMap ----------
function drawMiniMap(){
  if(!mapCtx) return;
  const g = world.grid;
  const W = world.w, H = world.h;
  const cw = mapCanvas.width, ch = mapCanvas.height;
  mapCtx.clearRect(0,0,cw,ch);

  const cell = Math.floor(Math.min(cw/W, ch/H));
  const ox = Math.floor((cw - cell*W)/2);
  const oy = Math.floor((ch - cell*H)/2);

  mapCtx.fillStyle = "rgba(255,255,255,0.04)";
  mapCtx.fillRect(0,0,cw,ch);

  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const isWall = (g[y][x]===1);
      mapCtx.fillStyle = isWall ? "rgba(10,16,30,0.85)" : "rgba(230,240,255,0.10)";
      mapCtx.fillRect(ox + x*cell, oy + y*cell, cell, cell);
    }
  }

  mapCtx.strokeStyle = "rgba(255,255,255,0.06)";
  mapCtx.lineWidth = 1;
  for(let x=0;x<=W;x++){
    mapCtx.beginPath();
    mapCtx.moveTo(ox + x*cell + 0.5, oy + 0.5);
    mapCtx.lineTo(ox + x*cell + 0.5, oy + H*cell + 0.5);
    mapCtx.stroke();
  }
  for(let y=0;y<=H;y++){
    mapCtx.beginPath();
    mapCtx.moveTo(ox + 0.5, oy + y*cell + 0.5);
    mapCtx.lineTo(ox + W*cell + 0.5, oy + y*cell + 0.5);
    mapCtx.stroke();
  }

  const gx = Math.round(world.goal.x / cellSize);
  const gy = Math.round(world.goal.z / cellSize);
  mapCtx.fillStyle = "rgba(120,250,255,0.95)";
  mapCtx.beginPath();
  mapCtx.arc(ox + (gx+0.5)*cell, oy + (gy+0.5)*cell, Math.max(3, cell*0.28), 0, Math.PI*2);
  mapCtx.fill();

  const px = Math.round(player.pos.x / cellSize);
  const py = Math.round(player.pos.z / cellSize);
  mapCtx.fillStyle = "rgba(255,120,120,0.98)";
  mapCtx.beginPath();
  mapCtx.arc(ox + (px+0.5)*cell, oy + (py+0.5)*cell, Math.max(3, cell*0.28), 0, Math.PI*2);
  mapCtx.fill();


  // enemies on minimap
  if(Array.isArray(enemies)){
    mapCtx.fillStyle = "rgba(255,90,130,0.95)";
    for(const e of enemies){
      const ex = Math.round((e.mesh?.position?.x ?? 0) / cellSize);
      const ez = Math.round((e.mesh?.position?.z ?? 0) / cellSize);
      if(ex>=0 && ez>=0 && ex<W && ez<H){
        mapCtx.beginPath();
        mapCtx.arc(ox + (ex+0.5)*cell, oy + (ez+0.5)*cell, Math.max(2, cell*0.24), 0, Math.PI*2);
        mapCtx.fill();
      }
    }
  }

  const dx = Math.sin(player.yaw), dz = Math.cos(player.yaw);
  mapCtx.strokeStyle = "rgba(255,180,180,0.95)";
  mapCtx.lineWidth = Math.max(2, cell*0.10);
  mapCtx.beginPath();
  mapCtx.moveTo(ox + (px+0.5)*cell, oy + (py+0.5)*cell);
  mapCtx.lineTo(ox + (px+0.5 + dx*0.6)*cell, oy + (py+0.5 + dz*0.6)*cell);
  mapCtx.stroke();
}
function openMiniMap(){
  if(!mapOverlay) return;
  mapOverlay.style.display = "block";
  positionMapPanel();
  drawMiniMap();
}
function closeMiniMap(){
  if(!mapOverlay) return;
  mapOverlay.style.display = "none";
}
let _mapToggleT = 0;
function toggleMiniMap(){
  // 同一タップで複数イベントが来て即開閉するのを防ぐ（答えが表示されない根本原因）
  const now = performance.now();
  if(now - _mapToggleT < 250) return;
  _mapToggleT = now;

  if(!mapOverlay) return;
  const d = mapOverlay.style.display;
  if(d && d !== "none") closeMiniMap();
  else openMiniMap();
}

btnAnswer?.addEventListener("click", toggleMiniMap);
btnAnswer?.addEventListener("pointerdown", (e)=>{ toggleMiniMap(); e.preventDefault(); e.stopPropagation(); });
btnAnswer?.addEventListener("touchstart", (e)=>{ toggleMiniMap(); e.preventDefault(); e.stopPropagation(); }, {passive:false});
mapClose?.addEventListener("click", closeMiniMap);
mapClose?.addEventListener("touchstart", (e)=>{ closeMiniMap(); e.preventDefault(); e.stopPropagation(); }, {passive:false});
mapClose?.addEventListener("pointerdown", (e)=>{ closeMiniMap(); e.preventDefault(); e.stopPropagation(); });

btnFoot?.addEventListener("click", ()=>setFootprintsEnabled(!footprintsEnabled));
btnFoot?.addEventListener("touchstart", (e)=>{ setFootprintsEnabled(!footprintsEnabled); e.preventDefault(); e.stopPropagation(); }, {passive:false});

// ---------- Touch sticks ----------
const stickL = document.getElementById("stickL");
const knobL = stickL.querySelector(".stickKnob");

function makeStick(stickEl, knobEl){
  const state = { active:false, id:null, x:0, y:0, cx:0, cy:0, max:0 };

  function center(){
    const r = stickEl.getBoundingClientRect();
    state.cx = r.left + r.width/2;
    state.cy = r.top  + r.height/2;
    state.max = r.width * 0.33;
  }
  function setKnob(nx, ny){
    knobEl.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
  }
  function reset(){ state.active=false; state.id=null; state.x=0; state.y=0; setKnob(0,0); }
  function onMove(px, py){
    const dx = px - state.cx, dy = py - state.cy;
    const d = Math.hypot(dx, dy);
    const m = state.max || 1;
    const s = d > m ? (m/d) : 1;
    const nx = dx * s, ny = dy * s;
    setKnob(nx, ny);
    state.x = nx / m;
    state.y = ny / m;
  }

  center();
  addEventListener("resize", center);

  stickEl.addEventListener("touchstart", (e)=>{
    for(const t of e.changedTouches){
      if(state.active) continue;
      state.active=true; state.id=t.identifier;
      center(); onMove(t.clientX, t.clientY);
      e.preventDefault(); break;
    }
  }, {passive:false});

  addEventListener("touchmove", (e)=>{
    if(!state.active) return;
    for(const t of e.changedTouches){
      if(t.identifier !== state.id) continue;
      onMove(t.clientX, t.clientY);
      e.preventDefault(); break;
    }
  }, {passive:false});

  addEventListener("touchend", (e)=>{
    if(!state.active) return;
    for(const t of e.changedTouches){
      if(t.identifier !== state.id) continue;
      reset(); e.preventDefault(); break;
    }
  }, {passive:false});

  addEventListener("touchcancel", (e)=>{
    if(!state.active) return;
    for(const t of e.changedTouches){
      if(t.identifier !== state.id) continue;
      reset(); e.preventDefault(); break;
    }
  }, {passive:false});

  return state;
}

const tMove = makeStick(stickL, knobL); // 左: 移動

// ---------- Player ----------
const player = {
  pos: new THREE.Vector3(),
  yaw: 0,
  pitch: 0,
  speed: 3.20,
  sprintMul: 1.45,
  radius: 0.35,
};

// スタート地点で“進める方向”を向く（壁を見ないように）
function computeStartYaw(){
  // start は (1,1) 固定
  const sx = 1, sz = 1;
  const g = world.grid;
  // 優先: 南→東→北→西
  const dirs = [
    {dx:0, dz:1,  yaw:0},
    {dx:1, dz:0,  yaw:Math.PI/2},
    {dx:0, dz:-1, yaw:Math.PI},
    {dx:-1,dz:0,  yaw:-Math.PI/2},
  ];
  for(const d of dirs){
    if(g?.[sz + d.dz]?.[sx + d.dx] === 0) return d.yaw;
  }
  return 0;
}

function resetPlayer(){
  player.pos.copy(world.start);
  player.yaw = computeStartYaw();
  player.pitch = 0;
  clearFootprints();
  toast("スタート位置へ");
}
resetPlayer();
setFootprintsEnabled(false);

btnReset.addEventListener("click", resetPlayer);
btnReset.addEventListener("touchstart", (e)=>{ resetPlayer(); e.preventDefault(); e.stopPropagation(); }, {passive:false});

function startGame(key){
  hasStarted = true;
  if(hud) hud.style.display = "block";
  updateMenuHeaderVisibility();
  goalReached = false;
  animate._goalFx = null;
  hintArrow.visible = false;
  hintUntil = 0;
  gameOver = false;
  if(gameOverEl) gameOverEl.style.display = "none";
  buildWorldByDifficulty(key);
  resetPlayer();
  spawnEnemies();
  hideMenu();
  toast((DIFF[key]?.label ?? "難しい") + " でスタート", 1200);
}
function backToMenu(){
  gameInMenu = true;
  updateMenuHeaderVisibility();
  if(menuOverlay) menuOverlay.style.display = "flex";
updateMenuHeaderVisibility();
}

function showMenu(){
  gameInMenu = true;
  updateMenuHeaderVisibility();
  if(menuOverlay) menuOverlay.style.display = "flex";
}
function hideMenu(){
  gameInMenu = false;
  if(menuOverlay) menuOverlay.style.display = "none";
}
diffEasy?.addEventListener("click", ()=>startGame("easy"));
diffEasy?.addEventListener("touchstart", (e)=>{ startGame("easy"); e.preventDefault(); e.stopPropagation(); }, {passive:false});
diffNormal?.addEventListener("click", ()=>startGame("normal"));
diffNormal?.addEventListener("touchstart", (e)=>{ startGame("normal"); e.preventDefault(); e.stopPropagation(); }, {passive:false});
diffHard?.addEventListener("click", ()=>startGame("hard"));
diffHard?.addEventListener("touchstart", (e)=>{ startGame("hard"); e.preventDefault(); e.stopPropagation(); }, {passive:false});
btnDifficulty?.addEventListener("click", showMenu);
btnDifficulty?.addEventListener("touchstart", (e)=>{ showMenu(); e.preventDefault(); e.stopPropagation(); }, {passive:false});
menuClose?.addEventListener("click", ()=>{ if(!hasStarted) return; hideMenu(); });
menuClose?.addEventListener("touchstart", (e)=>{ if(!hasStarted) return; hideMenu(); e.preventDefault(); e.stopPropagation(); }, {passive:false});
if(menuOverlay) menuOverlay.style.display = "flex";

// PC pointer lock（おまけ）
let pointerLocked = false;
renderer.domElement.addEventListener("click", ()=>renderer.domElement.requestPointerLock?.());
document.addEventListener("pointerlockchange", ()=>{
  pointerLocked = (document.pointerLockElement === renderer.domElement);
});
document.addEventListener("mousemove", (e)=>{
  if(!pointerLocked) return;
  const sens = 0.0022;
  player.yaw   -= e.movementX * sens;
  player.pitch -= e.movementY * sens;
  const lim = Math.PI*0.48;
  player.pitch = Math.max(-lim, Math.min(lim, player.pitch));
});

// スマホ: 画面スワイプで視点（スワイプは使わない）
const lookTouch = { active:false, id:null, lastX:0, lastY:0 };



function isInLeftStick(x,y){
  const r = stickL.getBoundingClientRect();
  return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
}
function isInHUD(x,y){
  // UI領域はスワイプ視点（lookTouch）開始の対象外にする（答え/閉じるが押せない原因対策）
  const ids = ["hud","mapPanel","menuPanel","gameOverPanel"];
  for(const id of ids){
    const el = document.getElementById(id);
    if(!el) continue;
    const r = el.getBoundingClientRect();
    if(x>=r.left && x<=r.right && y>=r.top && y<=r.bottom) return true;
  }
  return false;
}
function applySwipe(dx, dy){
  // px -> rad
  const sens = swipeSens;
  player.yaw   -= dx * sens;
  player.pitch -= dy * sens;
  const lim = Math.PI*0.48;
  player.pitch = Math.max(-lim, Math.min(lim, player.pitch));
}

renderer.domElement.addEventListener("touchstart", (e)=>{
  if(lookTouch.active) return;
  for(const t of e.changedTouches){
    const x = t.clientX, y = t.clientY;
    if(isInLeftStick(x,y) || isInHUD(x,y)) continue;
    if(x < innerWidth * 0.35) continue;
    lookTouch.active = true;
    lookTouch.id = t.identifier;
    lookTouch.lastX = x;
    lookTouch.lastY = y;
    e.preventDefault();
    break;
  }
},{passive:false});

addEventListener("touchmove", (e)=>{
  if(!lookTouch.active) return;
  for(const t of e.changedTouches){
    if(t.identifier !== lookTouch.id) continue;
    const dx = t.clientX - lookTouch.lastX;
    const dy = t.clientY - lookTouch.lastY;
    lookTouch.lastX = t.clientX;
    lookTouch.lastY = t.clientY;
    applySwipe(dx, dy);
    e.preventDefault();
    break;
  }
},{passive:false});

addEventListener("touchend", (e)=>{
  if(!lookTouch.active) return;
  for(const t of e.changedTouches){
    if(t.identifier !== lookTouch.id) continue;
    lookTouch.active = false;
    lookTouch.id = null;
    e.preventDefault();
    break;
  }
},{passive:false});

addEventListener("touchcancel", (e)=>{
  if(!lookTouch.active) return;
  for(const t of e.changedTouches){
    if(t.identifier !== lookTouch.id) continue;
    lookTouch.active = false;
    lookTouch.id = null;
    e.preventDefault();
    break;
  }
},{passive:false});

const keys = new Set();
addEventListener("keydown", e=>keys.add(e.key));
addEventListener("keyup", e=>keys.delete(e.key));

function getGamepad(){
  const pads = navigator.getGamepads?.();
  if(!pads) return null;
  for(const p of pads){ if(p && p.connected) return p; }
  return null;
}
function axisDeadzone(v, dz=0.18){
  if(Math.abs(v) < dz) return 0;
  const s = (Math.abs(v)-dz)/(1-dz);
  return Math.sign(v)*Math.min(1, s);
}

// Collision
function isWallAtWorld(x, z){
  const gx = Math.round(x / cellSize);
  const gz = Math.round(z / cellSize);
  if(gx<0||gz<0||gx>=world.w||gz>=world.h) return true;
  return world.grid[gz][gx] === 1;
}
function hitsWall(p){
  const r = player.radius;
  return (
    isWallAtWorld(p.x + r, p.z) ||
    isWallAtWorld(p.x - r, p.z) ||
    isWallAtWorld(p.x, p.z + r) ||
    isWallAtWorld(p.x, p.z - r)
  );
}
function collideMove(nextPos){
  const out = player.pos.clone();
  const tryX = new THREE.Vector3(nextPos.x, out.y, out.z);
  if(!hitsWall(tryX)) out.x = tryX.x;
  const tryZ = new THREE.Vector3(out.x, out.y, nextPos.z);
  if(!hitsWall(tryZ)) out.z = tryZ.z;
  return out;
}



/* ---------- Enemies ---------- */
let enemies = [];
let gameOver = false;

function enemyConfig(){
  if(currentDiffKey==="easy") return { count:1, speed:1.65, sight:6 };
  if(currentDiffKey==="normal") return { count:2, speed:1.95, sight:7 };
  return { count:3, speed:2.25, sight:8 };
}

const enemyMat = new THREE.MeshStandardMaterial({
  // 以前より“生っぽい”暗色にして不気味に
  color: 0x241018,
  emissive: 0x2b0010,
  emissiveIntensity: 1.05,
  roughness: 0.92,
  metalness: 0.02,
  transparent: true,
  opacity: 0.95
});

// 人型（不気味）: 低ポリ+細身+長い手足+光る目
function createCreepyHumanoid(r){
  const g = new THREE.Group();

  // 体
  const bodyGeo = new THREE.CapsuleGeometry(0.16, 0.56, 3, 10);
  const body = new THREE.Mesh(bodyGeo, enemyMat);
  body.position.y = 0.56;
  g.add(body);

  // 頭（少し大きめ）
  const headGeo = new THREE.SphereGeometry(0.20, 14, 10);
  const head = new THREE.Mesh(headGeo, enemyMat);
  head.position.y = 1.06;
  head.scale.set(1.05, 1.18, 1.00);
  g.add(head);

  // 首
  const neckGeo = new THREE.CylinderGeometry(0.08, 0.10, 0.14, 10);
  const neck = new THREE.Mesh(neckGeo, enemyMat);
  neck.position.y = 0.92;
  g.add(neck);

  // 腕（長め）
  const armGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.62, 8);
  const armL = new THREE.Mesh(armGeo, enemyMat);
  const armR = new THREE.Mesh(armGeo, enemyMat);
  armL.position.set(-0.22, 0.70, 0.00);
  armR.position.set( 0.22, 0.70, 0.00);
  armL.rotation.z =  0.20;
  armR.rotation.z = -0.20;
  g.add(armL, armR);

  // 手（爪っぽく）
  const handGeo = new THREE.ConeGeometry(0.07, 0.16, 8);
  const handL = new THREE.Mesh(handGeo, enemyMat);
  const handR = new THREE.Mesh(handGeo, enemyMat);
  handL.position.set(-0.22, 0.37, 0.02);
  handR.position.set( 0.22, 0.37, 0.02);
  handL.rotation.x = Math.PI;
  handR.rotation.x = Math.PI;
  g.add(handL, handR);

  // 脚（細め）
  const legGeo = new THREE.CylinderGeometry(0.055, 0.06, 0.58, 8);
  const legL = new THREE.Mesh(legGeo, enemyMat);
  const legR = new THREE.Mesh(legGeo, enemyMat);
  legL.position.set(-0.12, 0.18, 0.00);
  legR.position.set( 0.12, 0.18, 0.00);
  g.add(legL, legR);

  // 目（発光）
  const eyeMat = new THREE.MeshStandardMaterial({
    color: 0xffd1dc,
    emissive: 0xff2f6a,
    emissiveIntensity: 3.2,
    roughness: 0.20,
    metalness: 0.05
  });
  const eyeGeo = new THREE.SphereGeometry(0.045, 10, 8);
  const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
  const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
  eyeL.position.set(-0.075, 1.08, 0.16);
  eyeR.position.set( 0.075, 1.08, 0.16);
  g.add(eyeL, eyeR);

  // 影っぽい薄いオーラ（hardだけ強い）
  const auraGeo = new THREE.SphereGeometry(0.55, 14, 10);
  const auraMat = new THREE.MeshBasicMaterial({
    color: 0x2a0b18,
    transparent: true,
    opacity: (currentDiffKey==="hard") ? 0.18 : (currentDiffKey==="normal" ? 0.14 : 0.10),
    depthWrite: false
  });
  const aura = new THREE.Mesh(auraGeo, auraMat);
  aura.position.y = 0.65;
  aura.scale.set(1.0, 1.35, 1.0);
  g.add(aura);

  // ランダムな個体差
  const s = 0.95 + (r()*0.16);
  g.scale.set(s, s*(1.05 + r()*0.10), s);
  g.rotation.y = r()*Math.PI*2;

  // アニメ用の参照
  g.userData = {
    head,
    armL, armR,
    aura,
    eyeMat,
    baseY: 1.02,
    t: r()*10
  };
  return g;
}

function clearEnemies(){
  for(const e of enemies){
    scene.remove(e.mesh);
  }
  enemies = [];
}

function randomOpenCell(r, minDistCells=6){
  const sx=1, sz=1;
  const gx0 = Math.round(world.goal.x / cellSize);
  const gz0 = Math.round(world.goal.z / cellSize);

  for(let tries=0; tries<6000; tries++){
    const x = 1 + ((r()*(world.w-2))|0);
    const z = 1 + ((r()*(world.h-2))|0);
    if(world.grid[z][x]!==0) continue;

    const dx=x-sx, dz=z-sz;
    if(dx*dx+dz*dz < minDistCells*minDistCells) continue;

    const dgx=x-gx0, dgz=z-gz0;
    if(dgx*dgx+dgz*dgz < 4*4) continue;
    return {x,z};
  }
  return {x:world.w-2, z:1};
}

function neighborsOf(x,z){
  const n=[];
  if(world.grid[z]?.[x+1]===0) n.push({x:x+1,z});
  if(world.grid[z]?.[x-1]===0) n.push({x:x-1,z});
  if(world.grid[z+1]?.[x]===0) n.push({x,z:z+1});
  if(world.grid[z-1]?.[x]===0) n.push({x,z:z-1});
  return n;
}

function canSeePlayer(ex,ez, px,pz){
  const cfg = enemyConfig();
  if(ex===px){
    const d = Math.abs(ez-pz);
    if(d>cfg.sight) return null;
    const step = pz>ez ? 1 : -1;
    for(let z=ez+step; z!==pz; z+=step){
      if(world.grid[z][ex]===1) return null;
    }
    return {x:ex, z:ez+step};
  }
  if(ez===pz){
    const d = Math.abs(ex-px);
    if(d>cfg.sight) return null;
    const step = px>ex ? 1 : -1;
    for(let x=ex+step; x!==px; x+=step){
      if(world.grid[ez][x]===1) return null;
    }
    return {x:ex+step, z:ez};
  }
  return null;
}

function spawnEnemies(){
  clearEnemies();
  const cfg = enemyConfig();
  const rE = mulberry32(((DIFF[currentDiffKey]?.seed ?? 0xC0FFEE) ^ 0xDEAD1234) >>> 0);

  for(let i=0;i<cfg.count;i++){
    const c = randomOpenCell(rE, 7);
    const mesh = createCreepyHumanoid(rE);
    mesh.position.set(c.x*cellSize, 0.0, c.z*cellSize);
    scene.add(mesh);

    enemies.push({
      mesh,
      gx:c.x, gz:c.z,
      tx:c.x, tz:c.z,
      last:{x:c.x,z:c.z},
      speed: cfg.speed * (0.92 + rE()*0.22),
      t: rE()*10
    });
  }
}

function pickNextTarget(e){
  const px = Math.round(player.pos.x / cellSize);
  const pz = Math.round(player.pos.z / cellSize);

  const chase = canSeePlayer(e.gx, e.gz, px, pz);
  if(chase){
    e.tx = chase.x; e.tz = chase.z;
    return;
  }

  const neigh = neighborsOf(e.gx, e.gz);
  if(neigh.length===0) return;

  let cand = neigh;
  if(neigh.length>1){
    cand = neigh.filter(n=>!(n.x===e.last.x && n.z===e.last.z));
    if(cand.length===0) cand = neigh;
  }

  // prefer junctions
  cand.sort((a,b)=>neighborsOf(b.x,b.z).length - neighborsOf(a.x,a.z).length);

  if(cand.length>1 && Math.random() < 0.60){
    e.tx = cand[0].x; e.tz = cand[0].z;
  }else{
    const j = (Math.random()*cand.length)|0;
    e.tx = cand[j].x; e.tz = cand[j].z;
  }
}

function triggerGameOver(){
  if(gameOver) return;
  gameOver = true;
  toast("ゲームオーバー", 1200);
  if(gameOverEl) gameOverEl.style.display = "flex";
}

goMenuBtn?.addEventListener("click", ()=>{
goMenuBtn?.addEventListener("touchstart", (e)=>{ if(gameOverEl) gameOverEl.style.display = "none"; gameOver = false; backToMenu(); e.preventDefault(); e.stopPropagation(); }, {passive:false});
  if(gameOverEl) gameOverEl.style.display = "none";
  gameOver = false;
  backToMenu();
});

function updateEnemies(dt){
  if(gameOver || gameInMenu) return;
  const hitR2 = (0.74*0.74);

  for(const e of enemies){
    if(e.gx===e.tx && e.gz===e.tz){
      pickNextTarget(e);
    }

    const tx = e.tx*cellSize;
    const tz = e.tz*cellSize;
    const dx = tx - e.mesh.position.x;
    const dz = tz - e.mesh.position.z;
    const d = Math.hypot(dx,dz) || 1;

    const step = e.speed * dt;
    if(d <= step){
      e.mesh.position.x = tx;
      e.mesh.position.z = tz;
      e.last = {x:e.gx, z:e.gz};
      e.gx = e.tx; e.gz = e.tz;
    }else{
      e.mesh.position.x += (dx/d)*step;
      e.mesh.position.z += (dz/d)*step;
    }

    e.t += dt;
    // 人型の不気味さ：頭のわずかな傾き＋腕の振れ＋目の瞬き（hardほど強い）
    const ud = e.mesh.userData;
    if(ud){
      const k = (currentDiffKey==="hard") ? 1.0 : (currentDiffKey==="normal" ? 0.75 : 0.55);
      const s = Math.sin(ud.t + e.t*5.2);
      const c = Math.cos(ud.t + e.t*3.6);
      ud.head.rotation.y = 0.18*s*k;
      ud.head.rotation.z = 0.10*c*k;
      ud.armL.rotation.x = (0.35 + 0.20*s)*k;
      ud.armR.rotation.x = (0.35 - 0.20*s)*k;
      // 目の瞬き（発光強度をゆらす）
      if(ud.eyeMat){
        ud.eyeMat.emissiveIntensity = 2.6 + (1.2 + 1.2*k)*Math.max(0, Math.sin(e.t*8.0 + ud.t));
      }
      // オーラの脈動
      if(ud.aura){
        const p = 1.0 + 0.10*k*Math.sin(e.t*4.2 + ud.t);
        ud.aura.scale.set(p, 1.35*p, p);
      }
    }

    e.mesh.position.y = (e.mesh.userData?.baseY ?? 1.02) + Math.sin(e.t*6.0)*0.06;
    e.mesh.rotation.y += dt*2.1;

    const pdx = player.pos.x - e.mesh.position.x;
    const pdz = player.pos.z - e.mesh.position.z;
    if(pdx*pdx + pdz*pdz < hitR2){
      triggerGameOver();
      return;
    }
  }
}



// ---------- Goal effect ----------
function triggerGoalEffect(){
  if(goalReached) return;
  goalReached = true;

  // “見た目で一発で分かる”難易度差（色・リング段数・粒子種・画面揺れ）
  const fxCfg =
    (currentDiffKey==="easy")   ? { dur:1.10, flash:0.55, flashN:1, rings:1, shake:false,
                                   clouds:[ {N:760, pal:8,  size:0.13, boom:0.95, hue:190, sat:0.55, val:0.95} ],
                                   txtHue:190 } :
    (currentDiffKey==="normal") ? { dur:1.70, flash:0.78, flashN:2, rings:2, shake:false,
                                   clouds:[ {N:1400,pal:24, size:0.15, boom:1.18, hue:210, sat:0.85, val:0.98},
                                            {N:640, pal:12, size:0.18, boom:1.05, hue:48,  sat:0.95, val:1.00} ],
                                   txtHue:210 } :
                                 { dur:2.35, flash:0.96, flashN:3, rings:3, shake:true,
                                   clouds:[ {N:2400,pal:48, size:0.16, boom:1.42, hue:320, sat:1.00, val:1.00},
                                            {N:1400,pal:18, size:0.20, boom:1.25, hue:190, sat:0.95, val:1.00},
                                            {N:900, pal:10, size:0.23, boom:1.10, hue:60,  sat:0.25, val:1.00} ],
                                   txtHue:330 };

  // HSV -> RGB (0..1)
  function hsv2rgb(h,s,v){
    h = ((h%360)+360)%360;
    const c = v*s;
    const x = c*(1-Math.abs(((h/60)%2)-1));
    const m = v-c;
    let r=0,g=0,b=0;
    if(h<60){r=c;g=x;b=0;}
    else if(h<120){r=x;g=c;b=0;}
    else if(h<180){r=0;g=c;b=x;}
    else if(h<240){r=0;g=x;b=c;}
    else if(h<300){r=x;g=0;b=c;}
    else {r=c;g=0;b=x;}
    return [r+m,g+m,b+m];
  }
  function rgb255(rgb){
    return [Math.round(rgb[0]*255), Math.round(rgb[1]*255), Math.round(rgb[2]*255)];
  }
  function rgbToHex01(rgb){
    const r = Math.max(0,Math.min(255,(rgb[0]*255)|0));
    const g = Math.max(0,Math.min(255,(rgb[1]*255)|0));
    const b = Math.max(0,Math.min(255,(rgb[2]*255)|0));
    return (r<<16) | (g<<8) | b;
  }

  // 画面揺れ（hardだけ）
  if(fxCfg.shake) document.body.classList.add("goalShake");

  // フラッシュ（難易度で色が変わる＆複数回）
  if(flashEl){
    flashEl.style.display = "block";
    flashEl.style.background = "rgba(0,0,0,0)";
  }

  // GOAL テキスト（色の系統を難易度で変える）
  if(goalTextEl){
    goalTextEl.textContent = "GOAL";
    const tRGB = hsv2rgb(fxCfg.txtHue, 0.95, 1.0);
    const [r,g,b] = rgb255(tRGB);
    goalTextEl.style.color = `rgba(${r},${g},${b},0.98)`;
    goalTextEl.style.textShadow =
      (currentDiffKey==="easy")
        ? `0 0 10px rgba(${r},${g},${b},0.34), 0 0 26px rgba(${r},${g},${b},0.16)`
        : (currentDiffKey==="normal")
          ? `0 0 12px rgba(255,255,255,0.55), 0 0 34px rgba(${r},${g},${b},0.40), 0 0 70px rgba(${r},${g},${b},0.20)`
          : `0 0 12px rgba(255,255,255,0.70), 0 0 38px rgba(${r},${g},${b},0.62), 0 0 86px rgba(${r},${g},${b},0.30)`;

    goalTextEl.className = "show" + (currentDiffKey==="normal" ? " normal" : (currentDiffKey==="hard" ? " hard" : ""));
    goalTextEl.style.display = "block";
    void goalTextEl.offsetWidth;
  }

  // === 粒子クラウド（複数）===
  const clouds = [];
  for(const c of fxCfg.clouds){
    const N = c.N;
    const pos = new Float32Array(N*3);
    const vel = new Float32Array(N*3);
    const col = new Float32Array(N*3);

    // パレット（色数を増やす）
    const palette = [];
    for(let i=0;i<c.pal;i++){
      const hh = (c.hue + i*(360/c.pal) + (Math.random()*22-11)) % 360;
      const ss = Math.max(0, Math.min(1, c.sat * (0.85 + Math.random()*0.30)));
      const vv = Math.max(0, Math.min(1, c.val * (0.85 + Math.random()*0.25)));
      palette.push(hsv2rgb(hh, ss, vv));
    }

    const baseS = 2.6 * c.boom;
    const randS = 6.8 * c.boom;
    const spread = (currentDiffKey==="hard") ? 1.22 : (currentDiffKey==="normal" ? 1.08 : 0.96);

    for(let i=0;i<N;i++){
      pos[i*3+0] = world.goal.x;
      pos[i*3+1] = world.goal.y + 0.45;
      pos[i*3+2] = world.goal.z;

      // 方向：上方向を強める
      const a = Math.random()*Math.PI*2;
      const u = (Math.random()*2-1);
      const s = baseS + Math.random()*randS;
      const rr = Math.sqrt(1-u*u);

      vel[i*3+0] = Math.cos(a)*rr*s*spread;
      vel[i*3+1] = u*s*1.65 + (currentDiffKey==="hard" ? 2.8 : (currentDiffKey==="normal" ? 2.0 : 1.4));
      vel[i*3+2] = Math.sin(a)*rr*s*spread;

      const p = palette[(Math.random()*palette.length)|0];
      col[i*3+0] = p[0];
      col[i*3+1] = p[1];
      col[i*3+2] = p[2];
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    geo.setAttribute("color", new THREE.BufferAttribute(col, 3));

    const mat = new THREE.PointsMaterial({
      size: c.size,
      vertexColors: true,
      transparent: true,
      opacity: 1.0,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const pts = new THREE.Points(geo, mat);
    scene.add(pts);
    clouds.push({N, geo, mat, pts, vel, grav:(currentDiffKey==="hard"?7.8:(currentDiffKey==="normal"?7.1:6.4)) * c.boom, drag:(currentDiffKey==="hard"?0.20:0.16)});
  }

  // === リング（段数で差）===
  const ringHue0 = fxCfg.txtHue;
  const ringCols = [
    rgbToHex01(hsv2rgb(ringHue0, 0.90, 1.0)),
    rgbToHex01(hsv2rgb((ringHue0+120)%360, 0.95, 1.0)),
    rgbToHex01(hsv2rgb((ringHue0+240)%360, 0.95, 1.0)),
  ];
  const rings = [];

  function addRing(rIn, rOut, seg, color, op, yOff){
    const g = new THREE.RingGeometry(rIn, rOut, seg);
    const m = new THREE.MeshBasicMaterial({
      color, transparent:true, opacity:op,
      side:THREE.DoubleSide, blending:THREE.AdditiveBlending
    });
    const mesh = new THREE.Mesh(g, m);
    mesh.position.set(world.goal.x, world.goal.y + yOff, world.goal.z);
    mesh.rotation.x = -Math.PI/2;
    scene.add(mesh);
    rings.push({g,m,mesh});
  }

  addRing(0.42, 0.64, 72, ringCols[0], 0.98, 0.25);
  if(fxCfg.rings >= 2) addRing(0.78, 1.02, 84, ringCols[1], 0.78, 0.26);
  if(fxCfg.rings >= 3) addRing(1.16, 1.42, 96, ringCols[2], 0.58, 0.27);

  // サウンド（差をさらに強く：hardは重低音＋長め）
  try{
    const ac = new (window.AudioContext||window.webkitAudioContext)();
    const g = ac.createGain(); g.connect(ac.destination);

    const o1 = ac.createOscillator(); o1.type = "sine";
    const o2 = ac.createOscillator(); o2.type = "triangle";
    const o3 = ac.createOscillator(); o3.type = "square";

    const durS = (currentDiffKey==="easy") ? 0.30 : (currentDiffKey==="normal" ? 0.48 : 0.78);

    if(currentDiffKey==="easy"){
      o1.frequency.setValueAtTime(880, ac.currentTime);
      o1.frequency.exponentialRampToValueAtTime(1760, ac.currentTime+0.14);
      o2.frequency.setValueAtTime(440, ac.currentTime);
      o2.frequency.exponentialRampToValueAtTime(880, ac.currentTime+0.16);
    }else if(currentDiffKey==="normal"){
      o1.frequency.setValueAtTime(740, ac.currentTime);
      o1.frequency.exponentialRampToValueAtTime(2200, ac.currentTime+0.16);
      o2.frequency.setValueAtTime(370, ac.currentTime);
      o2.frequency.exponentialRampToValueAtTime(1200, ac.currentTime+0.18);
    }else{
      o1.frequency.setValueAtTime(520, ac.currentTime);
      o1.frequency.exponentialRampToValueAtTime(2600, ac.currentTime+0.20);
      o2.frequency.setValueAtTime(260, ac.currentTime);
      o2.frequency.exponentialRampToValueAtTime(1300, ac.currentTime+0.22);
      o3.frequency.setValueAtTime(90, ac.currentTime);
      o3.frequency.exponentialRampToValueAtTime(180, ac.currentTime+0.12);
    }

    g.gain.setValueAtTime(0.0001, ac.currentTime);
    g.gain.exponentialRampToValueAtTime((currentDiffKey==="hard") ? 0.28 : 0.20, ac.currentTime+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+durS);

    o1.connect(g); o2.connect(g); if(currentDiffKey==="hard") o3.connect(g);
    o1.start(); o2.start(); if(currentDiffKey==="hard") o3.start();
    o1.stop(ac.currentTime+durS+0.03);
    o2.stop(ac.currentTime+durS+0.03);
    if(currentDiffKey==="hard") o3.stop(ac.currentTime+durS+0.03);
  }catch(_){}

  toast("ゴール！！", 1600);

  let tt = 0;
  const dur = fxCfg.dur;

  function stepFx(dt){
    tt += dt;
    const p = Math.min(1, tt/dur);

    // フラッシュ：複数回波形
    if(flashEl){
      let w = 0;
      if(fxCfg.flashN===1){
        w = 1-p;
      }else if(fxCfg.flashN===2){
        // 2段：前半強く→後半もう一回
        w = Math.max(0, (1-p) * (p<0.55 ? 1.0 : 0.6)) + Math.max(0, (0.92 - p) * (p>0.55 ? 1.2 : 0.0));
      }else{
        // 3段：ストロボっぽく
        const s = Math.sin(tt*18.0);
        w = Math.max(0, (1-p) * (0.55 + 0.45*Math.abs(s)));
      }
      const rgb = hsv2rgb(fxCfg.txtHue, (currentDiffKey==="easy"?0.35:(currentDiffKey==="normal"?0.55:0.85)), 1.0);
      const [r,g,b] = rgb255(rgb);
      flashEl.style.background = `rgba(${r},${g},${b},${fxCfg.flash*w})`;
      if(p>=1){
        flashEl.style.display = "none";
      }
    }

    // GOALテキスト cleanup
    if(goalTextEl && tt >= dur){
      goalTextEl.style.display = "none";
      goalTextEl.className = "";
      goalTextEl.style.color = "";
      goalTextEl.style.textShadow = "";
    }

    // リング更新（回転方向/速さも難易度で違う）
    for(let i=0;i<rings.length;i++){
      const R = rings[i];
      const boost = (i===0?10.0:(i===1?13.0:16.0));
      const s = 1 + p*(boost * (currentDiffKey==="hard"?1.15:(currentDiffKey==="normal"?1.0:0.85)));
      R.mesh.scale.set(s,s,s);
      R.m.opacity = (i===0?0.98:(i===1?0.78:0.58)) * (1-p);

      const dir = (i%2===0)?1:-1;
      const sp = (currentDiffKey==="hard") ? (2.8 + i*1.1) : (currentDiffKey==="normal" ? (1.5 + i*0.7) : (0.8 + i*0.4));
      R.mesh.rotation.z += dt * sp * dir;
    }

    // 粒子更新
    for(const C of clouds){
      const arr = C.geo.attributes.position.array;
      for(let i=0;i<C.N;i++){
        const ix = i*3;
        arr[ix+0] += C.vel[ix+0]*dt;
        arr[ix+1] += C.vel[ix+1]*dt;
        arr[ix+2] += C.vel[ix+2]*dt;

        // 重力＋空気抵抗
        C.vel[ix+1] -= C.grav*dt;
        C.vel[ix+0] *= (1 - C.drag*dt);
        C.vel[ix+2] *= (1 - C.drag*dt);
      }
      C.geo.attributes.position.needsUpdate = true;
      C.mat.opacity = 1.0*(1-p);
    }

    if(tt >= dur){
      // remove
      for(const C of clouds){
        scene.remove(C.pts);
        C.geo.dispose(); C.mat.dispose();
      }
      for(const R of rings){
        scene.remove(R.mesh);
        R.g.dispose(); R.m.dispose();
      }

      if(world.goalMesh){
        world.group.remove(world.goalMesh);
        world.goalMesh = null;
      }

      animate._goalFx = null;

      // shake off
      document.body.classList.remove("goalShake");

      backToMenu();
    }
  }

  animate._goalFx = stepFx;
}

let lastT = performance.now();
function animate(t){
  requestAnimationFrame(animate);
  animate._mm = (animate._mm ?? 0) + 1;
  const dt = Math.min(0.033, (t-lastT)/1000);
  lastT = t;

  // menu中は操作を止める
  const menuOpen = (menuOverlay && menuOverlay.style.display !== "none");
  if(gameOver){
    updateHintArrow(t);
    if(animate._goalFx) animate._goalFx(dt);
    if(mapOverlay && mapOverlay.style.display !== "none" && (animate._mm % 4 === 0)) drawMiniMap();
    renderer.render(scene, camera);
    return;
  }

  const pad = getGamepad();
  if(padEl) padEl.textContent = pad ? `Gamepad: ${pad.id.split("(")[0].trim()}（接続中）` : "Gamepad: 未接続";

  let moveX = 0, moveZ = 0;
  let lookX = 0, lookY = 0;
  let sprint = false;

  if(menuOpen){
    // 何もしない（表示だけ）
  }

  if(pad){
    moveX = axisDeadzone(pad.axes[0] ?? 0);
    moveZ = axisDeadzone(pad.axes[1] ?? 0);
    lookX = axisDeadzone(pad.axes[2] ?? 0, 0.14);
    lookY = axisDeadzone(pad.axes[3] ?? 0, 0.14);
    sprint = !!(pad.buttons[5]?.pressed || pad.buttons[4]?.pressed);
  }else{
    // ★ここが修正点：移動スティックの左右を反転
    moveX += (-tMove.x);
    moveZ += ( tMove.y);
  }

  // keyboard fallback
  const w = keys.has("w") || keys.has("W");
  const a = keys.has("a") || keys.has("A");
  const s = keys.has("s") || keys.has("S");
  const d = keys.has("d") || keys.has("D");
  if(w) moveZ -= 1;
  if(s) moveZ += 1;
  if(a) moveX -= 1;
  if(d) moveX += 1;
  if(keys.has("Shift")) sprint = true;

  if(keys.has("ArrowLeft"))  lookX -= 0.85;
  if(keys.has("ArrowRight")) lookX += 0.85;
  if(keys.has("ArrowUp"))    lookY -= 0.85;
  if(keys.has("ArrowDown"))  lookY += 0.85;

  // view
  const lookSens = 2.20;
  player.yaw   -= lookX * lookSens * dt;
  player.pitch -= lookY * lookSens * dt;
  const lim = Math.PI*0.48;
  player.pitch = Math.max(-lim, Math.min(lim, player.pitch));

  // move
  const len = Math.hypot(moveX, moveZ);
  if(len > 1){ moveX/=len; moveZ/=len; }
  const spd = player.speed * (sprint ? player.sprintMul : 1);

  const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));

  const vel = new THREE.Vector3()
    .addScaledVector(right,  moveX * spd)
    .addScaledVector(forward, -moveZ * spd);

  const next = player.pos.clone().addScaledVector(vel, dt);
  player.pos.copy(collideMove(next));
  // footprints（OFFでも記録し、ONにしたら表示される）
  {
    const gx = Math.round(player.pos.x / cellSize);
    const gz = Math.round(player.pos.z / cellSize);
    if(gx>=0 && gz>=0 && gx<world.w && gz<world.h && world.grid[gz][gx]===0){
      const key = gx + "," + gz;
      if(!visited.has(key)){
        visited.add(key);
        ensureFootAssets();
        const m = new THREE.Mesh(footGeo, footMat);
        m.rotation.x = -Math.PI/2;
        m.rotation.z = (Math.random()*0.6 - 0.3);
        m.position.set(gx*cellSize, floorY + 0.02, gz*cellSize);
        footGroup.add(m);
      }
    }
  }

  // camera
  camera.position.set(player.pos.x, player.pos.y, player.pos.z);
  const dirVec = new THREE.Vector3(
    Math.sin(player.yaw) * Math.cos(player.pitch),
    Math.sin(player.pitch),
    Math.cos(player.yaw) * Math.cos(player.pitch)
  );
  camera.lookAt(player.pos.clone().add(dirVec));

  updateEnemies(dt);
  updateHintArrow(t);

  // lights follow player (torch points forward)
  const eye = new THREE.Vector3(player.pos.x, player.pos.y + 0.25, player.pos.z);
  torch.position.copy(eye);
  torch.target.position.copy(eye.clone().add(forward.multiplyScalar(3.0)));
  rim.position.set(player.pos.x - forward.x*1.6, player.pos.y + 0.7, player.pos.z - forward.z*1.6);
  // goal
  if(world.goalMesh){
    world.goalMesh.rotation.y += dt*0.9;

    const dx = player.pos.x - world.goal.x;
    const dz = player.pos.z - world.goal.z;
    const d2 = dx*dx + dz*dz;
    if(d2 < (0.85*0.85)){
      triggerGoalEffect();
    }
  }

  if(animate._goalFx) animate._goalFx(dt);

  if(mapOverlay && mapOverlay.style.display !== "none" && (animate._mm % 4 === 0)) drawMiniMap();

  renderer.render(scene, camera);
}
requestAnimationFrame(animate);

// resize
addEventListener("resize", ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  positionMapPanel();
});
</script>
</body>
</html>
