<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Star Dodge 〜星間サバイバル〜</title>
  <style>
    /* ---- iOS Safari のスクロール・ラバーバンド防止 ---- */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;                /* スクロール領域を作らない */
      touch-action: none;              /* ジェスチャーでスクロールしない */
      overscroll-behavior: none;       /* ラバーバンド抑止（対応ブラウザ） */
      background: #000814;
      color: #e6edf3;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    /* ページ自体を固定（iOSのアドレスバー伸縮でも動かない） */
    body {
      position: fixed;
      inset: 0;
      -webkit-overflow-scrolling: auto;
    }

    #game { position: fixed; inset: 0; touch-action: none; background:#000814; }

    .hud{position:fixed;left:12px;top:10px;font-weight:700;line-height:1.15;z-index:2}
    .level{font-size:22px;margin-bottom:2px}
    .score{font-size:18px}
    .hud small{display:block;font-weight:500;opacity:.75;font-size:12px;margin-top:2px}
    .btns{position:fixed;right:12px;top:12px;display:flex;gap:8px;z-index:2}
    button{background:#14213d;color:#e6edf3;border:1px solid #21355a;border-radius:10px;padding:10px 14px;font-size:14px}
    button:active{transform:scale(.98)}
    .stick{position:fixed;left:50%;bottom:12px;transform:translateX(-50%);width:140px;height:140px;border-radius:50%;background:#0b1324cc;border:1px solid #21355a;z-index:2;touch-action:none}
    .knob{position:absolute;left:50%;top:50%;width:56px;height:56px;margin:-28px 0 0 -28px;border-radius:50%;background:#1b2a41;border:1px solid #2d466f}
    .center{position:fixed;inset:0;display:grid;place-items:center;text-align:center;padding:24px;z-index:3}
    .card{background:#0b1324e6;border:1px solid #21355a;border-radius:12px;padding:18px 20px;max-width:560px}
    .toast{position:fixed;left:50%;top:18%;transform:translateX(-50%);background:#0b1324cc;border:1px solid #21355a;border-radius:10px;padding:8px 12px;font-weight:700;z-index:2}
    .hidden{display:none}
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud">
  <div id="level" class="level">LEVEL: 1</div>
  <div id="score" class="score">SCORE: 0</div>
  <small id="hiscore">High: 0</small>
</div>
<div class="btns">
  <button id="pauseBtn">一時停止</button>
  <button id="restartBtn">リスタート</button>
</div>
<div class="stick" id="stick"><div class="knob" id="knob"></div></div>
<div class="center" id="overlay" style="display:none">
  <div class="card">
    <h2 style="margin:.2em 0">Star Dodge 〜星間サバイバル〜</h2>
    <p style="margin:.2em 0 .6em">操作：中央下スティック／右上ボタン</p>
    <p style="margin:.2em 0 0.35em">🟡 <b>黄色い⭐</b>＝取ると <b>スコア+1</b>（レベルアップに必要）</p>
    <p style="margin:.2em 0 1em">🟦 <b>青いオーブ</b>＝取ると <b>15秒無敵</b>（外周ゲージで残り時間表示）</p>
    <button id="startBtn">スタート</button>
  </div>
</div>
<div id="toast" class="toast hidden">LEVEL UP!</div>
<script>
(() => {
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const hiEl = document.getElementById('hiscore');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const toast = document.getElementById('toast');
  const btns = document.querySelector('.btns');
  const stickEl = document.getElementById('stick');

  // ---- iOS スクロール完全ロック ----
  // 1) ページが少しでもスクロールしたら即座に戻す
  const lockScroll = () => { window.scrollTo(0, 0); };
  window.addEventListener('scroll', lockScroll, { passive: true });
  // 2) 画面全体の touchmove を既定で阻止（ゲーム操作は個別でハンドル）
  document.addEventListener('touchmove', (e) => {
    // UIボタン・スティック以外のスクロールを全ブロック
    if (!e.target.closest('.stick') && !e.target.closest('.btns')) {
      e.preventDefault();
    }
  }, { passive: false });
  // 3) ダブルタップ拡大なども抑止
  let lastTouch = 0;
  document.addEventListener('touchend', (e) => {
    const now = performance.now();
    if (now - lastTouch < 300) e.preventDefault();
    lastTouch = now;
  }, { passive: false });

  // ---- Config ----
  const INV_DURATION = 5.0;
  const SPAWN_HOLD = 0.9;
  const PEEK_PIX_BASE = 18;
  const BULLET_SPEED = 160;
  const BULLET_RADIUS = 5;
  const SHOOT_LEVEL = 5;
  const CHARGE_TIME = 0.6;
  const STAR_WATCHDOG = 5.0;
  const INV_PICKUP_PAD = 3;
  const INV_TTL = 15.0;
  const INV_WARN = 1.0;

  // CSS pixel size for logic
  let CW = 0, CH = 0; // canvas size in CSS px

  // Items BEFORE fit()
  const star = { x: 0, y: 0, r: 9 };
  const invItem = { active:false, x:0, y:0, r:9, ttl:0 };
  let starMissingTimer = 0;
  let invTimer = 0;

  function clampInside(obj, margin){
    const m = margin||24;
    obj.x = Math.max(m, Math.min(CW - m, obj.x));
    obj.y = Math.max(m, Math.min(CH - m, obj.y));
  }

  function visualSize(){
    const vv = window.visualViewport;
    return {
      w: Math.round((vv ? vv.width : window.innerWidth)),
      h: Math.round((vv ? vv.height : window.innerHeight))
    };
  }

  // ---- Locked background (offscreen bitmap) ----
  let bgCanvas = null, bgW = 0, bgH = 0;
  function buildBackground(w, h, dpr){
    const bg = document.createElement('canvas');
    bg.width = Math.floor(w * dpr);
    bg.height = Math.floor(h * dpr);
    bg.style.width = w + 'px';
    bg.style.height = h + 'px';
    const bctx = bg.getContext('2d');
    bctx.setTransform(dpr,0,0,dpr,0,0);

    bctx.fillStyle = '#000814';
    bctx.fillRect(0,0,w,h);

    const g = bctx.createRadialGradient(w*0.5, h*0.6, 0, w*0.5, h*0.6, Math.max(w,h)*0.75);
    g.addColorStop(0, 'rgba(0, 25, 55, 0.65)');
    g.addColorStop(1, 'rgba(0, 8, 20, 0)');
    bctx.fillStyle = g;
    bctx.beginPath(); bctx.rect(0,0,w,h); bctx.fill();

    const count = Math.floor((w*h)/9000);
    bctx.fillStyle = '#ffffff';
    for(let i=0;i<count;i++){
      const x = Math.random()*w;
      const y = Math.random()*h;
      const r = Math.random()*1.1 + 0.2;
      const a = 0.35 + Math.random()*0.4;
      bctx.globalAlpha = a;
      bctx.beginPath(); bctx.arc(x,y,r,0,Math.PI*2); bctx.fill();
    }
    bctx.globalAlpha = 1;

    bgCanvas = bg; bgW = w; bgH = h;
  }
  function drawBackground(){
    if(bgCanvas) ctx.drawImage(bgCanvas, 0, 0, bgW, bgH);
  }

  function fit(force=false){
    const {w,h} = visualSize();
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    if(!force && w === CW && h === CH) return;

    CW = w; CH = h;
    cvs.width = Math.floor(w * dpr);
    cvs.height = Math.floor(h * dpr);
    cvs.style.width = w + 'px';
    cvs.style.height = h + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);

    if(Number.isFinite(star.x) && Number.isFinite(star.y)) clampInside(star, 24);
    if(invItem && invItem.active && Number.isFinite(invItem.x) && Number.isFinite(invItem.y)) clampInside(invItem, 28);

    buildBackground(w, h, dpr);
    lockScroll(); // リサイズ後に念のためスクロール位置を戻す
  }
  window.addEventListener('resize', ()=>fit(false), {passive:true});
  window.addEventListener('orientationchange', ()=> setTimeout(()=>fit(true), 120), {passive:true});
  if(window.visualViewport){
    visualViewport.addEventListener('resize', ()=> setTimeout(()=>fit(false), 0), {passive:true});
  }
  setTimeout(()=>fit(true), 0);

  // UI avoid
  function getUIRects(){
    const list = [];
    if(btns){
      const r = btns.getBoundingClientRect();
      list.push({type:'rect', x:r.left, y:r.top, w:r.width, h:r.height, pad:12});
    }
    if(stickEl){
      const s = stickEl.getBoundingClientRect();
      const cx = s.left + s.width/2;
      const cy = s.top + s.height/2;
      const rad = Math.max(s.width, s.height)/2 + 16;
      list.push({type:'circle', cx, cy, r:rad});
    }
    return list;
  }
  function overlapsUI(x,y,r){
    const uis = getUIRects();
    for(const u of uis){
      if(u.type==='rect'){
        const rx1 = u.x - u.pad, ry1 = u.y - u.pad;
        const rx2 = u.x + u.w + u.pad, ry2 = u.y + u.h + u.pad;
        const nx = Math.max(rx1, Math.min(x, rx2));
        const ny = Math.max(ry1, Math.min(y, ry2));
        if((nx-x)**2 + (ny-y)**2 < (r+2)**2) return true;
      }else{
        const dx = x - u.cx, dy = y - u.cy;
        if(dx*dx + dy*dy < (r + u.r)**2) return true;
      }
    }
    return false;
  }
  function randomPos(m){ return { x: m + Math.random()*(CW-2*m), y: m + Math.random()*(CH-2*m) }; }
  function placeWithUIAvoid(obj, margin, maxTry=50){
    const m = margin||24;
    for(let i=0;i<maxTry;i++){
      const p = randomPos(m);
      if(!overlapsUI(p.x, p.y, obj.r)) { obj.x=p.x; obj.y=p.y; return true; }
    }
    const p = randomPos(m); obj.x=p.x; obj.y=p.y; return false;
  }

  let running = false, paused = false, tPrev = 0;
  let score = 0, hiscore = +localStorage.getItem('orb_hi') || 0;
  let level = 1;
  hiEl.textContent = 'High: ' + hiscore;

  // Player
  const player = { x: 0, y: 0, r: 12, speed: 220, vx:0, vy:0 };

  function placeStar() { placeWithUIAvoid(star, 24); starMissingTimer = 0; }
  function isStarVisible(){
    return Number.isFinite(star.x) && Number.isFinite(star.y) &&
           star.x >= 0 && star.x <= CW && star.y >= 0 && star.y <= CH;
  }
  function isStarObscuredByUI(){ return overlapsUI(star.x, star.y, star.r); }

  function spawnInvItem(){
    invItem.ttl = INV_TTL;
    invItem.active = true;
    placeWithUIAvoid(invItem, 28);
  }
  function grantInvincibility(){ invTimer = INV_DURATION; invItem.active = false; }

  // Enemies & bullets
  const enemies = [];
  const bullets = [];
  function addEnemy() {
    const edge = Math.floor(Math.random()*4);
    const r = 12+Math.random()*8;
    let sx, sy;
    if(edge===0){ sx = -r; sy = Math.random()*CH; }
    else if(edge===1){ sx = CW + r; sy = Math.random()*CH; }
    else if(edge===2){ sx = Math.random()*CW; sy = -r; }
    else { sx = Math.random()*CW; sy = CH + r; }

    const ang = Math.atan2(player.y - sy, player.x - sx) + (Math.random()*0.6-0.3);
    const ux = Math.cos(ang), uy = Math.sin(ang);
    const peekDist = PEEK_PIX_BASE + r * 0.7;
    const tx = sx + ux * peekDist;
    const ty = sy + uy * peekDist;
    const base = 60 + Math.random()*80 + Math.min(140, score*2);
    const vx = ux * base, vy = uy * base;

    const isShooter = (level >= SHOOT_LEVEL) && (Math.random() < 0.2);
    const shootCd = 2.0 + Math.random()*0.4;
    enemies.push({
      x:sx, y:sy, r,
      state:'spawn', spawnTimer:SPAWN_HOLD, sx, sy, tx, ty,
      vx, vy, ux, uy,
      shooter:isShooter, shootTimer:shootCd, charge:0,
      aimUx:0, aimUy:0, aimHold:0
    });
  }
  function enemyShoot(e){
    const vx = e.aimUx * BULLET_SPEED;
    const vy = e.aimUy * BULLET_SPEED;
    bullets.push({ x:e.x, y:e.y, vx, vy, r:BULLET_RADIUS, ttl:4.5 });
    e.aimHold = 0.08;
  }
  for(let i=0;i<3;i++) addEnemy();
  let enemyTimer = 0;

  // Stick
  const knob = document.querySelector('.knob');
  let dragging=false, dirX=0, dirY=0;
  function stickPos(clientX, clientY){
    const rect = stickEl.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = clientX - cx, dy = clientY - cy;
    const max = rect.width*0.38;
    const d = Math.hypot(dx,dy) || 1;
    const nx = dx/d * Math.min(d, max);
    const ny = dy/d * Math.min(d, max);
    knob.style.transform = `translate(${nx}px, ${ny}px)`;
    dirX = (dx/d) * Math.min(d/max, 1);
    dirY = (dy/d) * Math.min(d/max, 1);
    if(!dragging){ dirX=0; dirY=0; knob.style.transform='translate(0,0)'; }
  }
  stickEl.addEventListener('touchstart', e=>{ dragging=true; stickPos(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
  stickEl.addEventListener('touchmove',  e=>{ if(dragging){ stickPos(e.touches[0].clientX, e.touches[0].clientY); } }, {passive:false});
  stickEl.addEventListener('touchend',   ()=>{ dragging=false; dirX=dirY=0; knob.style.transform='translate(0,0)'; }, {passive:true});
  stickEl.addEventListener('mousedown',  e=>{ dragging=true; stickPos(e.clientX,e.clientY); });
  addEventListener('mousemove', e=>{ if(dragging) stickPos(e.clientX,e.clientY); });
  addEventListener('mouseup', ()=>{ dragging=false; dirX=dirY=0; knob.style.transform='translate(0,0)'; });

  function updateLevel(prevScore, newScore){
    const prevLevel = Math.floor(prevScore/5)+1;
    const newLevel  = Math.floor(newScore/5)+1;
    if(newLevel > prevLevel){
      level = newLevel;
      levelEl.textContent = 'LEVEL: ' + level;
      showToast();
    }
  }
  let toastTimer = 0;
  function showToast(){ toast.classList.remove('hidden'); toast.style.opacity = '1'; toastTimer = 0.9; }

  function reset(){
    const {w,h} = visualSize();
    CW = w; CH = h;
    // 画面固定の安全策
    lockScroll();
    setTimeout(lockScroll, 0);

    player.x=CW*0.5; player.y=CH*0.6; player.vx=player.vy=0;
    score=0; level=1;
    scoreEl.textContent='SCORE: 0';
    levelEl.textContent='LEVEL: 1';
    enemies.length=0; bullets.length=0;
    for(let i=0;i<3;i++) addEnemy(); enemyTimer=0; placeStar();
    paused=false; pauseBtn.textContent='一時停止';
    toast.classList.add('hidden');
    invItem.active=false; invTimer=0; starMissingTimer = 0;
  }
  function start(){ running=true; tPrev=performance.now(); requestAnimationFrame(loop); }
  function stop(){ running=false; overlay.style.display='grid';
    if(score>hiscore){ hiscore=score; localStorage.setItem('orb_hi', hiscore); hiEl.textContent='High: '+hiscore; } }

  // ---- Enemies & bullets update (dynamic aim) ----
  function updateEnemies(dt){
    enemies.forEach(e=>{
      if(e.state === 'spawn'){
        const total = SPAWN_HOLD;
        const progress = Math.min(1, (total - e.spawnTimer) / total);
        e.x = e.sx + (e.tx - e.sx)*progress;
        e.y = e.sy + (e.ty - e.sy)*progress;
        e.spawnTimer -= dt;
        if(e.spawnTimer <= 0){ e.state = 'live'; }
      } else {
        e.x += e.vx*dt; e.y += e.vy*dt;

        if(e.shooter){
          // チャージ中は常にプレイヤー方向にエイム、発射時にその向きで撃つ
          if(e.shootTimer <= CHARGE_TIME && e.shootTimer > 0){
            e.charge = e.shootTimer;
          }
          const angAim = Math.atan2(player.y - e.y, player.x - e.x);
          e.aimUx = Math.cos(angAim); e.aimUy = Math.sin(angAim);

          e.shootTimer -= dt;
          if(e.shootTimer <= 0){
            enemyShoot(e);
            e.shootTimer = 2.0 + Math.random()*0.4;
            e.charge = 0;
          }
          if(e.aimHold > 0){ e.aimHold -= dt; if(e.aimHold < 0) e.aimHold = 0; }
        }
      }
    });
  }
  function updateBullets(dt){
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx*dt; b.y += b.vy*dt;
      b.ttl -= dt;
      if(b.ttl <= 0 || b.x<-20 || b.x>CW+20 || b.y<-20 || b.y>CH+20){
        bullets.splice(i,1);
      }
    }
  }

  function loop(tNow){
    if(!running) return;
    const dt = Math.min(0.033, (tNow - tPrev)/1000); tPrev = tNow;

    if(!paused){
      if(invItem.active){ invItem.ttl -= dt; if(invItem.ttl <= 0){ invItem.active = false; } }
      if(invTimer > 0){ invTimer -= dt; if(invTimer < 0) invTimer = 0; }

      player.x += (dirX * player.speed)*dt;
      player.y += (dirY * player.speed)*dt;
      player.x = Math.max(player.r, Math.min(CW - player.r, player.x));
      player.y = Math.max(player.r, Math.min(CH - player.r, player.y));

      enemyTimer += dt;
      const interval = Math.max(0.6, 2.2 - score*0.05);
      if(enemyTimer > interval){ addEnemy(); enemyTimer=0; }

      updateEnemies(dt); updateBullets(dt);

      const isInv = invTimer > 0;
      for(const e of enemies){
        if(e.state === 'live' && !isInv){
          if((e.x-player.x)**2 + (e.y-player.y)**2 < (e.r+player.r)**2){ stop(); }
        }
      }
      if(!isInv){
        for(const b of bullets){
          if((b.x-player.x)**2 + (b.y-player.y)**2 < (b.r+player.r)**2){ stop(); }
        }
      }

      if((star.x-player.x)**2 + (star.y-player.y)**2 < (star.r+player.r)**2){
        const prev = score;
        score++; scoreEl.textContent = 'SCORE: ' + score;
        updateLevel(prev, score);
        placeStar();
        if(!invItem.active && invTimer<=0 && Math.random() < 0.10) spawnInvItem();
      }

      if(isStarVisible() && !isStarObscuredByUI()){ starMissingTimer = 0; }
      else { starMissingTimer += dt; if(starMissingTimer >= STAR_WATCHDOG) placeStar(); }

      if(toastTimer > 0){ toastTimer -= dt; if(toastTimer <= 0) toast.classList.add('hidden'); }
    }

    // DRAW
    ctx.clearRect(0,0,CW,CH);
    drawBackground();

    // ⭐ yellow: bright with outline + glow
    ctx.save();
    ctx.shadowColor = '#f7c843'; ctx.shadowBlur = 10;
    ctx.fillStyle='#ffd54a';
    ctx.beginPath(); ctx.arc(star.x, star.y, star.r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    ctx.strokeStyle='#ffffff'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(star.x, star.y, star.r+1, 0, Math.PI*2); ctx.stroke();

    if(invItem.active){
      const dx = invItem.x - player.x, dy = invItem.y - player.y;
      const inRange = (dx*dx + dy*dy) < (player.r + invItem.r + INV_PICKUP_PAD)**2;
      const blinkPhase = (invItem.ttl < INV_WARN) ? (Math.sin(performance.now()/50) > 0 ? 1 : 0.3) : 1;
      ctx.globalAlpha = blinkPhase;
      ctx.fillStyle = '#58a6ff';
      ctx.beginPath(); ctx.arc(invItem.x, invItem.y, invItem.r, 0, Math.PI*2); ctx.fill();
      const fracTTL = Math.max(0, Math.min(1, invItem.ttl/INV_TTL));
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#9ec6ff'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(invItem.x, invItem.y, invItem.r+5, -Math.PI/2, -Math.PI/2 + fracTTL*2*Math.PI); ctx.stroke();
      ctx.strokeStyle = inRange ? '#b9d9ff' : '#9ec6ff'; ctx.lineWidth = inRange ? 3 : 2;
      ctx.beginPath(); ctx.arc(invItem.x, invItem.y, invItem.r+2, 0, Math.PI*2); ctx.stroke();
      if(inRange) grantInvincibility();
    }

    // Enemies
    enemies.forEach(e=>{
      if(e.state === 'spawn'){
        ctx.globalAlpha = 0.7;
        ctx.fillStyle='#ff8181';
        ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle='#ffb4b4'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(e.x + e.ux*14, e.y + e.uy*14); ctx.stroke();
      } else {
        // shooter color tweak: warm orange
        ctx.fillStyle = e.shooter ? '#ff8a3d' : '#ff4d4f';
        ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();

        if(e.shooter){
          // charge ring
          if(e.charge > 0){
            const frac = e.charge / CHARGE_TIME;
            ctx.strokeStyle='#ffd19a'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.arc(e.x, e.y, e.r + 4 + 6*frac, 0, Math.PI*2); ctx.stroke();
          }
          // aim line: charging → always toward player, short
          const len = 10;
          const ax = e.x + (e.aimUx||0)*len;
          const ay = e.y + (e.aimUy||0)*len;
          const show = (e.charge > 0) || (e.aimHold > 0);
          if(show){
            ctx.strokeStyle = '#ffe680'; ctx.lineWidth = 2.2; ctx.globalAlpha = (e.aimHold>0?0.6:0.95);
            ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(ax, ay); ctx.stroke();
            ctx.globalAlpha = 1;
          }
        }
      }
    });

    // bullets
    ctx.fillStyle = '#ff7b7b';
    bullets.forEach(b=>{ ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill(); });

    const isInv = invTimer > 0;
    ctx.fillStyle = isInv ? '#b3e5ff' : '#ffffff';
    ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle='#aab1b8'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(player.x, player.y, player.r+3, 0, Math.PI*2); ctx.stroke();
    if(isInv){
      const frac = invTimer / INV_DURATION;
      ctx.strokeStyle = '#58a6ff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r+7, -Math.PI/2, -Math.PI/2 + frac*2*Math.PI);
      ctx.stroke();
    }

    requestAnimationFrame(loop);
  }

  // Start
  function forceShowOverlay(){ overlay.style.display='grid'; }
  function forceStart(){ if(!running){ reset(); start(); } }
  forceShowOverlay();
  setTimeout(forceStart, 800);
  window.addEventListener('pointerdown', ()=> forceStart(), {once:true, passive:true});
  startBtn.onclick = ()=>{ overlay.style.display='none'; reset(); start(); };
  restartBtn.onclick = ()=>{ reset(); start(); };
  pauseBtn.onclick = ()=>{ if(!running) return; paused=!paused; pauseBtn.textContent = paused?'再開':'一時停止'; };

})();</script>
</body>
</html>
